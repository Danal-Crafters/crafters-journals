# Vibe coding은 우리를 대체할 수 있을까
![img.png](../img.png)

2025년 현재, 우리는 개발이라는 행위 자체가 빠르게 재정의되고 있는 전환점에 서 있습니다.

이제는 코드 한 줄을 손으로 작성하는 대신, 대화를 통해 기능을 구현하고, 스펙을 설명하면 자동으로 프로젝트가 구성되는 시대가 되었습니다.

이 모든 변화의 중심에는 'AI'가 있습니다.

그리고 이러한 변화 속에서 탄생한 새로운 개발 패러다임이 바로 **바이브 코딩(Vibe Coding)** 입니다.

오늘은 요즘 세간에서 꽤 많은 인기를 끌고 있는 바이브 코딩에 대한 제 경험과 생각을 공유드리고자 합니다.

# 바이브 코딩이란?
말 그대로, 느낌대로 코딩하는 기법을 의미합니다.

겉보기엔 멋진 용어처럼 보이지만, 사실 ‘바이브 코딩’이라는 그럴듯한 단어가 등장하기 전부터도 이미 존재해왔던 방식이라고 할 수 있습니다.

예전부터 개발자에게는 ‘슈도코드’라는 이름으로, 기획자에게는 ‘요구사항 명세서’로, 그리고 사업가에게는 ‘사업기획서’로
각자의 영역에서 비슷한 형태로 존재해왔습니다.

즉, 프로그램이나 서비스, 혹은 사업 등 어떤 것이든 ‘무엇이며, 어떤 기능을 하고, 어떻게 구현되어야 하는지’를 정리해두었다면,
그것은 나름대로 바이브 코딩의 초기 형태라고 볼 수 있지 않을까 합니다.

## 왜 요즘따라 화제일까?
ChatGPT의 등장으로, 사람들은 ‘내가 해야 할 일을 AI에게 맡기는 방식’이 얼마나 시간을 단축시켜줄 수 있는지 체감하게 되었습니다.

가장 가깝게는 검색부터, 내 할 일 스케줄링, 의사결정 대체(점심메뉴 선택), AI를 이용한 스터디 등 정말 다양한 분야에서 AI를 사용하고 시간을 아낄 수 있습니다.

이렇게 AI가 일상에 자연스럽게 스며들기 전, 얼리어답터 집단인 개발자들은 자신이 해야 할 작업을 AI에게 맡기기 시작했습니다.

**이것이 바이브 코딩의 시초라고 볼 수 있습니다.**

개발자들은 ‘내가 직접 코드를 작성하지 않아도, 기능에 대한 명확한 명세만 있다면 충분히 시간을 절약할 수 있다’는 점에 감탄하게 됩니다.

특히, 내가 사용하는 언어나 프레임워크에 대한 깊은 지식이 없어도 요구사항에 대해 최적의 구현안을 어느 정도 완성할 수 있다는 점에서 큰 감동을 받습니다.

이제 개발자들은 자신의 지식 수준에 갇히지 않고, 원하는 기능을 구현하기 위한 의사결정과 업무를 더욱 자유롭게 진행할 수 있게 되었습니다.

이것을 보며 알 수 있었습니다.

### **"개발자가 조금 더 하고싶은 분야에 집중할 수 있게 만드는 코딩 방법이구나"**

정정리하자면, 바이브 코딩은 개발자 관점에서 언어나 동작 방식, 프레임워크 등에 구애받지 않고 원하는 것을 구현하는 새로운 패러다임이라고 볼 수 있습니다.

말만 들으면 굉장히 멋지고, 뭐든 다 할 수 있을 것 같은 느낌을 줍니다.

하지만 저는 바이브 코딩에 대해 다소 회의적인 시각을 가지고 있습니다.

어쩌면 ‘수단과 방법을 가리지 않고 일단 원하는 걸 만들어본다’는 방식에 가깝다고 생각하기도 합니다.

AI가 서운하지 않게, 실제로 직접 활용해 보았습니다.


# 바이브 코딩으로 만든 자동배포 시스템

### [GitHub Link](https://github.com/adszzz11/auto-deploy-shell)

회사에서는 CI/CD 작업을 수행해야 하는 경우가 꽤 자주 발생합니다.

겉보기에는 CI/CD가 쉽게 느껴질 수 있지만, 실제로는 생각보다 고려해야 할 사항이 많은 까다로운 프로세스입니다.

특히 GitOps를 도입하게 되면, 이 문제는 더욱 두드러지게 나타납니다.

저희 회사는 **Kubernetes(k8s)**와 같은 오케스트레이션 도구를 사용하지 않기 때문에,
ArgoCD와 같이 CD를 자동화해주는 툴을 적용할 수 없는 상황이었습니다.

그래서 저는, ArgoCD의 역할을 어느 정도 대체할 수 있는 도구를 직접 만들어 보기로 했습니다.

그 결과물이 바로, 위 링크에 있는 Auto-Deploy-Shell입니다.

이제, 먼저 요구사항부터 살펴보겠습니다.
~~~
1. Github을 사용하고, GitHub Actions 생태계를 회사 아키텍처에 사용하고 있다.
2. 폐쇄망에 있는 서버에 지시를 하여 대상 서버로 배포를 시도해야 한다.
3. Container 환경을 사용하지 않는 일반 환경이고, 이 서버를 실행하기 위해 일정 명령어를 리눅스에서 실행해야 한다.
4. 한 서버에서 배포할 때 트래픽 유입에 장애가 생기면 안 된다.
5. 장애가 발생하거나, 배포에 실패할 경우 모든 인스턴스를 이전 버전으로 원복한다.
~~~
오늘 주제가 바이브 코딩인 만큼, AI에게 물어보겠습니다.

### [채팅 링크](https://chatgpt.com/share/67f3ee9f-f54c-8006-80f3-e2aace933c53)

겉보기에는 마치 완벽한 시스템을 만든 것처럼 이야기하고 있지만, 실제로 뜯어보면 ‘예쁜 쓰레기’에 가깝다고 판단할 수 있습니다.

당연한 이야기입니다. ChatGPT는 제가 진짜로 원하는 것을 정확히 알지 못한 채,
단지 제가 적어둔 내용을 바탕으로 분석하고 코드를 생성해줄 뿐입니다.

이런 식으로 바이브 코딩을 시작하게 되면, AI에게
“아니야 아니야, 다시 해봐”라고 반복적으로 요청하다가
결국 혼내고 있는 제 모습을 발견하게 됩니다.

이 패턴이 반복되다 보면, 직접 구현하는 것보다 오히려 더 많은 시간이 소요되기도 하고,
막상 나온 결과물은 기대에 미치지 못하는 경우도 생깁니다.

지금까지는 전체 컨텍스트를 AI에게 던지고, 결과가 마음에 들지 않으면
꾸짖듯이 다시 요청하는 방식으로 접근해왔습니다.

그래서 이번에는 조금 전략을 바꿔,
저도 직접 공부하며 AI를 도구로 삼는 방식으로 활용해 보았습니다.

## 요구사항에 대한 구간을 나누자.
하나의 컨텍스트 안에서 모든 작업을 진행하다 보면,

AI가 갑자기 “이 기술 스택으로는 잘 안 되네요. 그런데 이걸로는 이렇게 할 수 있어요”라며

자기 멋대로 방향을 바꾸거나, 기술 스택을 수정해버리는 상황이 발생하기도 합니다.

사람도 마찬가지입니다.

기획부터 요구사항 명세, 기술 스택 선정, 개발, 유지보수까지 모든 단계를 혼자 진행하다 보면

정말 수많은 갈림길에 서게 되고,

그때마다 선택을 반복하면서 이전의 결정을 되돌려야 하는 일도 자주 생깁니다.

하지만 제가 원하는 방식은 이런 흐트러짐이 아닙니다.

그래서 저는 전체 과정을 구간별로 나누고,

각 구간마다 역할을 분리해 여러 AI에게 분담시키는 전략을 주로 사용합니다.

구현할 부분에 대해 
- 기술스택 선정 단계 
- 요구사항 명세 및 구현 단계
- 세분화 및 테스트 단계 

정도로 나누어서 AI를 사용합니다.

## 실제로 한 번 나누어 보면

우선, 이 기능을 구현하는 데 필요한 기술 스택을 신중하게 고민하고,
기존에 알고 있는 기술보다 더 적합한 대안이 있는지도 함께 탐색해보았습니다.

그 결과, 무중단 배포에는 nginx, 자동 배포 구성에는 shell 스크립트가 가장 적합하다는 결론에 도달했습니다.

다음 단계로, 선정한 기술 스택이 중간에 변경되지 않도록
해당 내용을 AI의 메모리에 명확하게 각인시킨 후, 실제 구현 작업에 착수했습니다.

이전에 스스로 내린 기술적 의사결정을 건드리지 않도록 설계한 덕분에,
처음에 결정한 기술 스택을 최대한 활용하여 끝까지 구현을 이어갈 수 있었습니다.

AI는 완벽하지 않기 때문에, 지속적인 검증과 테스트 과정이 반드시 필요합니다.

제가 작성하지 않은 코드이기 때문에, AI가 생성한 코드를 마치 코드 리뷰하듯이 꼼꼼히 확인하고 테스트하는 과정에 의미가 있습니다.

이러한 일련의 과정을 모두 거치고 나니,
이제는 어느 정도 동작하는 기본적인 로직을 완성할 수 있게 되었습니다.
~~~
이러한 방식이 가능했던 가장 큰 이유는,
제가 DevOps 생태계에 익숙하고, AI 없이도 해당 기능을 구현할 수 있는 수준의 지식을 갖추고 있었기 때문일 것입니다.

하지만 이 과정은 개인의 경험과 숙련도에 따라 충분히 세분화될 수 있습니다.
따라서, ‘내가 확신을 가질 수 있을 때까지’ 단계를 나눠보고,
그에 맞는 전략을 스스로 구성해보시는 것을 추천드립니다.
~~~

위 과정을 직접 따라 해보신 분들이라면 아마 공감하실 텐데,
대부분은 두 번째 단계, 즉 실제 구현 단계에서 많은 어려움을 겪게 됩니다.

그 이유는 아마도, AI가 만들어낸 코드가 ‘올바른 코드인지’ 검증할 없기 때문일 것입니다.

## 코드 구현을 지시할 때, 구현해야할 기능을 최대한 잘게 쪼개어 시켜보자.
AI가 만들어낸 결과물이라 하더라도, 그에 대한 검증과 유지보수는 결국 인간이 책임져야 하는 상황이 생기기 마련입니다.

그러기 위해서는, AI가 어떤 기능을 구현했는지, 그리고 그것이 어떻게 동작하는지를 개발자가 이해하고 있어야 합니다.

이는 마치 코드 리뷰를 할 때와 유사합니다.

전체 애플리케이션이 완성된 이후에 리뷰를 진행하게 되면, “이 애플리케이션에는 문제가 없습니다”라고 자신 있게 말할 수 있는 사람은 극히 드뭅니다.

그 이유는, 코드의 양이 방대해질수록 세세한 부분까지 꼼꼼히 확인하는 것이 점점 어려워지기 때문입니다.

AI에게도 마찬가지입니다.

처음부터 너무 방대한 작업을 시키게 되면, 내가 기대했던 수준의 구현이 나오지 않을 가능성이 높습니다.

이를 방지하려면, 정말 세세한 수준까지 매니징하고, 조정해가며 AI를 활용해야 합니다.

하지만 그렇게 하다 보면 결국에는,
“이럴 거면 차라리 내가 직접 구현하지” 라는 생각이 들기도 합니다.

### 살짝 개념을 바꾸어, AI와 페어 프로그래밍을 한다는 관점으로 접근하면
AI가 생성한 코드에 대해 어느 정도 신뢰가 생기고,
그 코드를 제가 이어받아 유지보수할 수 있는 수준이라면, 이후 작업도 충분히 이어갈 수 있습니다.

이러한 전제가 충족되어야
검증 과정에서 누락되었거나 부족했던 부분을 보완할 수 있고,
나아가 ‘사람이 이해하기 쉬운 코드’로 점차 개선해나갈 수 있습니다.

## 가장 문제는, 테스트와 검증, 버그에 대한 수정이다.
AI는 마치 “자, 원하는 기능 다 만들어줬어요!” 하고 기뻐하는 듯하지만,
사실 기능을 만든 이후가 진짜 시작입니다.

기능을 구현하는 것과 실제로 그것을 실생활에 적용하는 일은 완전히 다른 문제입니다.

이 부분은 아마 대부분의 개발자들이 깊이 공감하실 것입니다.

직접 사용하려고 가져와 보면, 이전에는 보이지 않았던 차원의 문제들에 마주하게 되고,

심지어 문제에 직면하지 않더라도,
애초에 기획 단계에서의 오류나 부족함을 뒤늦게 발견하는 경우도 흔합니다.

AI에게 테스트도 맡겨보려고 여러 시도를 해보았지만,
아직까지는 “내가 직접 실행해보고 오류가 발생하면 그때 물어보는 방식”보다 더 효율적인 방법을 찾긴 어려웠습니다.

AI에게 ‘내 컴퓨터에서 테스트 환경을 구성하고 테스트하는 법’까지 전부 가르쳐주는 것도 하나의 방법이 될 수 있겠지만,

솔직히 말해 “그럴 바엔 내가 직접 하지”라는 마음이 들어 결국 포기하게 되었습니다.

제가 자주 방문하는 AI 커뮤니티나 주변 개발자들과의 논의에서도,
이 부분은 아직 많은 발전이 필요한 영역이라는 데에 대부분 동의하는 분위기였습니다.



# 내가 느낀 바이브 코딩의 단점
## 우선, 아직 모두가 ‘삽질하는’ 단계.
“저는 이렇게 사용하고 있어요”라는 식의 유즈케이스가 하나둘씩 등장하고는 있습니다.

이런 모습은 어쩌면 그때 당시 새로운 패러다임의 초창기 모습이지 않을까, 하는 생각입니다.

레퍼런스가 없는 무언가에 도전한다는 것,
그 자체가 언제나 두려움을 동반하는 일일 것입니다.
## AI가 만든걸 믿을 수 있을까?
좋은 서비스, 좋은 시스템이란 결국 ‘내가 진정으로 믿을 수 있는 것’이어야 한다고 생각합니다.

AI를 도구로 활용해 만든 서비스라 하더라도,
결국 그것은 제 이름으로 세상에 나가게 됩니다.

그렇다면 과연, 그 결과물을 제가 진심으로 신뢰할 수 있을까요?

AI의 할루시네이션이 발생한다면
그에 따라 소스코드의 품질은 급격히 저하될 수밖에 없고,

그렇지 않더라도 ‘내가 정확히 이해하지 못하는 코드’에 대해서는
쉽게 신뢰를 갖기 어려운 것이 사실입니다.

물론, 바이브 코딩이라는 개발 문화의 정착, AI에 대한 파인튜닝,
또는 코드 리뷰와 테스트 체계를 통해

각 문제에 대한 해결책은 충분히 존재할 수 있습니다.

하지만 그럼에도 불구하고, AI가 만들어낸 소스코드에 대해
제 마음이 쉽게 안심할 수는 없을 것 같다는 생각이 드는 것도 사실입니다.

## AI가 만든걸 유지보수할 땐 어떻게 해야하지?
제가 만든 소스코드에서 버그가 있다는 제보를 타인으로부터 받게 되면,
결국 그 소스코드를 직접 들여다보며 트러블슈팅을 진행하게 되는 사람은 대부분 저 자신일 가능성이 높습니다.

설령 직접 해결하지 않더라도,
그 제보에 대한 대응과 후속 처리는 결국 제 몫이 될 수밖에 없습니다.

즉, 결국은 제가 소스코드를 다시 들여다보게 된다는 뜻입니다.

앞서 말씀드린 프로세스를 차근차근 따라가며
AI가 생성한 코드에 대해 어느 정도 이해를 했다고 하더라도,

그 코드는 제가 직접 작성한 것이 아니기 때문에 기억에 오래 남지 않는다는 단점이 존재합니다.

결국 다시 AI에게 생성된 코드를 모두 넣고, 상황을 설명하며 트러블슈팅을 요청하는 상황으로 돌아가게 되는데,

이 과정은 제가 직접 구현했던 경우보다 오히려 더 많은 시간이 소요될 수 있습니다.

경우에 따라서는 두 배 이상의 시간이 걸릴 수도 있습니다.

우리는 보통 ‘유지보수가 쉬운 코드’를 지향하지만,
이러한 상황을 보면 어쩐지 무언가 잘못된 방향으로 가고 있는 듯한 느낌이 들기도 합니다.
## 기능을 만들어준댔지, 예쁘게 만들어준다고는 안 했다.
처음에 완성된 Shell Script는,
하나의 파일에 모든 기능이 다 담겨 있는 이른바 '1000줄짜리 코드'였습니다.

기능 자체는 동작하니 “완성”이라고 할 수는 있었지만,

중복된 코드를 분리하거나, 가독성을 높이기 위해 파일을 나눈다거나,
그 어떤 유지보수성을 고려한 설계도 적용되지 않은 상태였습니다.

결국 이 구조를 나누기 위해서는 제가 직접 AI에게 구체적으로 지시해야 했고,
이 과정에서

‘IntelliJ 없이 메모장만으로 소스코드를 리팩토링한다는 게 얼마나 답답한 일인지’를
간접적으로 체감하게 되었습니다.

정리하자면, 유지보수성은 정말 심각하게 떨어지는 상태였습니다.

AI에게 맡기자니 아직 신뢰가 부족하고,
제가 직접 하자니 유지보수와 리팩토링이 너무나도 번거로운 상황이었습니다.

결국 선택한 방법은,
AI가 가진 지식과 기능을 최대한 끌어오되,
제가 모든 단계를 마이크로매니징하며 개발을 주도하는 방식이었습니다.

# 그럼, 어떻게 바이브 코딩을 받아들여야 할까?
바이브 코딩이 실제로 도움이 될 것 같은 직군을 몇 개 생각해 보았습니다.
## 개발자 관점에서
개발자에게 있어서, 언어나 프레임워크 등 기술적인 제약을 없애주었다는 것만으로도
AI는 이미 상당히 큰 진전을 이뤄냈다고 볼 수 있습니다.

이제 개발자는 “내가 가진 지식으로 어떻게 만들지?”보다는
“무엇을 만들고 싶은가?”에 조금 더 집중할 수 있게 되었습니다.

원하는 기능을 구현할 때, AI의 도움을 받으며 함께 만들어갈 수 있다는 점 역시 큰 장점입니다.

무엇보다, 내가 해야 할 작업을 작게 나누어 여러 AI에게 분산시켜 맡길 수 있기 때문에,
그 과정에서 개발자에게 가해지는 부담을 어느 정도 줄일 수 있는 것도 사실입니다.
## 테스터 관점에서
제가 운영 업무를 하면서 테스트를 집중적으로 수행해야 했던 시기에는,
소스코드를 100% 파악한 상태에서 테스트를 진행하는 것에 어려움을 느낀 적이 꽤 많았습니다.

정해진 시간 안에 많은 테스트를 빠르게 수행하고,
이후에는 실제 서비스에 반영하는 작업까지 이어져야 하다 보니,
소스코드에 대한 충분한 이해 없이 테스트를 진행했던 경우도 있었던 것 같습니다.

이럴 때, AI의 도움을 받아 소스코드를 요약하거나,
에러가 발생할 가능성이 있는 부분을 사전 점검하는 등의 방식으로
제가 놓칠 수 있는 부분을 어느 정도 보완할 수 있지 않을까 하는 기대가 생깁니다.

물론 CI 과정에서 기본적인 테스트는 어느 정도 자동화되어 있지만,
화이트박스 테스트 수준의 정밀한 검증 역시 AI가 일정 부분 도와줄 수 있을 것이라 생각하고 있습니다.

다만, 이 모든 과정에서 중요한 점은 역시 보안입니다.

소스코드를 외부에 반출하거나 업로드하는 행위는 중대한 보안 위반이 될 수 있기 때문에,
AI 활용 전에는 반드시 보안 요건에 대한 충분한 검토와 사내 정책 준수가 필요합니다.

## 기획자 관점에서
제가 작성한 요구사항이 실제 소스코드에서 제대로 반영되고 있는지를 검증하는 과정은
사실상 거의 없었던 것 같습니다.

대부분은 테스트 케이스를 통해 간접적으로 확인하는 방식이었는데,

이제는 소스코드를 분석할 수 있는 AI 도구가 부하처럼 함께한다면

요구사항과 구현 코드 간의 맥락이 일치하는지 검증하는 일도
어느 정도 가능하지 않을까 기대해보고 있습니다.

사실, 요구사항 기반 테스트 케이스를 작성하는 일 자체가 꽤 고된 업무인데,

AI에게 맡겨본 결과, 기본적인 수준에서는 꽤 잘 수행하는 모습을 확인할 수 있었습니다.

물론, 개발자의 코드 스타일이나 구현 방식에 따라
테스트 케이스의 구조나 방향은 달라질 수 있기 때문에,

AI를 제대로 활용하려면 미리 테스트 케이스 작성에 대한 컨벤션이나 포맷을 정해두는 것이 중요하다고 생각합니다.



## 비개발자 관점에서
사실 이건 모든 개발자에게 공통적으로 해당되는 이야기일지도 모릅니다.

반복적이고 짜증나는 일들,
이런 작업들은 대부분 자동화가 가능하다는 점을 여러 차례 체감해왔습니다.

이러한 문제를 해결하는 과정에는 다양한 접근 방식이 있겠지만,

이제는 ‘바이브 코딩’으로 만들어낸 프로그램도
그 중 하나의 유효한 해결책이 될 수 있다는 가능성을 확인하게 되었습니다.

“하... 이거 너무 귀찮은데, 해결 방법 없을까?”
라는 말을 정말 자주 듣곤 하는데,
이제는 그런 질문에 대해 AI가 적어도 하나쯤은 해결 방안을 제안할 수 있는 시대가 된 것 같습니다.
![img.png](../img_1.png)
# 마치며
위의 과정을 어느 정도 정리해 이해할 수 있는 수준에 이르기까지,
정말 많은 시간이 걸렸습니다.

수없이 많은 삽질과 시행착오를 겪었고,
아마 지금 이 순간에도 현 세대의 많은 개발자들이 저와 비슷한 경험을 동시에 하고 있지 않을까 싶습니다.

앞서 말씀드린 것처럼, 아직 ‘바이브 코딩’으로 실질적인 개발 업무를 수행하기에는 무리가 있습니다.

개발자가 단순히 코드를 만들기만 하고 끝나는 역할이라면 큰 문제가 되지 않을 수도 있지만,

우리는 언제나 미래의 유지보수와 확장성까지 고려해야 하며
이 부분에 있어서는 AI가 그 중요성과 맥락을 온전히 이해하지 못한다는 점이 한계로 느껴집니다.

‘바이브 코딩’은 객체지향이나 절차지향처럼 이론적으로 정의되고 체계화된 개념이라기보다는,

마치 ‘모든 걸 알고 있지만, 시키는 일만 하는 조력자’와 대화하는 느낌에 더 가깝기 때문에
개념적으로도 이해하고 정리하기가 쉽지 않은 측면이 있습니다.

그럼에도 불구하고, 인류는 언제나 더 나은 방향으로 나아가기 위해 노력해왔고, 앞으로도 그럴 것입니다.

바이브 코딩이라는 새로운 개발 패러다임이 앞으로 어떻게 성장하고 진화할지, 그 가능성을 기대해 봅니다.