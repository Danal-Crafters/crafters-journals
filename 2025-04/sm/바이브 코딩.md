# Vibe coding은 우리를 대체할 수 있을까
![img.png](img.png)
2025년 현재, 우리는 개발이라는 행위 그 자체가 빠르게 재정의되고 있는 전환점에 서 있다. 

코드 한 줄을 손으로 짜는 대신, 대화를 통해 기능을 구현하고, 스펙을 설명하면 자동으로 프로젝트가 구성된다. 

이 모든 변화의 중심에는 'AI'가 있다. 

그리고 이런 변화 속에서 탄생한 새로운 개발 패러다임, 그것이 바로 **바이브 코딩(Vibe Coding)** 이다.

오늘은, 요새 세간에서 꽤나 인기몰이 중인 바이브 코딩에 대한 경험과, 나의 생각을 공유한다.

# 바이브 코딩이란?
말 그대로, 느낌대로 코딩하는 기법을 말한다. 

뭔가 멋진 단어지만, 바이브 코딩이라고 이런 뭔가 그럴싸한 단어를 꺼내기 전에도 존재해왔던 것이라고 할 수 있다.

예전부터 개발자에게는 '슈도코드'로, 기획자에는 '요구사항 명세'로, 사업가에게는 '사업기획서'로

각자 나름의 방식대로 존재해왔다.

그냥, 프로그램, 서비스, 사업 등 어떤 것이라도 '이게 어떤 것이고, 어떤 기능을 하고, 어떻게 해야함'을 정리했다면

나름 바이브 코딩의 조상 어딘가쯤이지 않을까 한다.

## 왜 요즘따라 화제일까?
ChatGPT의 등장으로, 사람들은 '내가 할 일을 AI에게 시키는 방식'이 얼마나 내 시간을 단축시켜줄 수 있는지 알게 되었다.

가장 가깝게는 검색부터, 내 할 일 스케줄링, 의사결정 대체(점심메뉴 선택), AI를 이용한 스터디 등 정말 다양한 분야에서 AI를 사용하고 시간을 아낄 수 있다.

이렇게 일상에 자연스레 스며들기 전, 얼리 어답터 덩어리인 개발자들은 자기 할 일을 AI에게 던지면서 대신 일을 시키기 시작했다.

**이것이 바이브 코딩의 시초라고 볼 수 있다.**

개발자들은 '내가 반드시 코딩하는 것이 아닌, 기능에 대한 자세한 명세'만으로도 내가 할애할 시간을 꽤나 아낄 수 있음에 감탄한다.

특히, 내가 만들어야 할 요구사항에 대한 최적의 답안을 내가 그 언어나 프레임워크를 잘 모르더라도 어느정도 구현할 수 있다는 것에 큰 감동을 받을 수 있다.

점점 개발자들은 원하는 것에 대한 구현을 위해 '내가 아는 지식 수준에 갇히지 않고' 자유롭게 의사결정 및 업무를 진행할 수 있다.

이제 알 수 있다.

### **"개발자가 조금 더 하고싶은 분야에 집중할 수 있게 만드는 코딩 방법이구나"**

정리하면, 바이브 코딩은 '개발자 관점에서, 언어나 동작방식, 프레임워크 등 개발 방식에 구애받지 않고 원하는 것을 구현하는 새로운 패러다임'

정도로 정리할 수 있을 것 같다.

말만 들으면 되게 멋지고 뭔가 다 할 수 있을것만 같은데

나는 바이브 코딩에 대해 조금 회의적인 입장을 가지고 있다.

살짝, '수단과 방법을 가리지 않고 원하는걸 일단 만들어본다' 기법 정도?

말만 하면 AI 서러울라, 직접 한 번 써봤다.

# 바이브 코딩으로 만든 자동배포 시스템

### [GitHub Link](https://github.com/adszzz11/auto-deploy-shell)

회사에서, CI/CD를 할 일이 꽤나 자주 생긴다.

CI/CD가 되게 쉽게 다가오는데, 이게 생각보다 고려할 게 되게 많은 까다로운 프로세스이다.

GitOps를 들여온다면 더더욱 이 문제가 부각되는데

우리 회사는 k8s같은 오케스트레이션 도구를 사용하지 않으니, ArgoCD같이, CD를 자동화해주는 툴은 사용할 수 없었다.

그래서 나는, ArgoCD의 역할을 어느정도 대체할 아이를 직접 만들어보기로 했다.

그것이, 위의 링크에 있는 Auto-Deploy-Shell이다.

우선, 요구사항을 확인해보자.
~~~
1. Github을 사용하고, GitHub Actions 생태계를 회사 아키텍처에 사용하고 있다.
2. 폐쇄망에 있는 서버에 지시를 하여 대상 서버로 배포를 시도해야 한다.
3. Container 환경을 사용하지 않는 일반 환경이고, 이 서버를 실행하기 위해 일정 명령어를 리눅스에서 실행해야 한다.
4. 한 서버에서 배포할 때 트래픽 유입에 장애가 생기면 안 된다.
5. 장애가 발생하거나, 배포에 실패할 경우 모든 인스턴스를 이전 버전으로 원복한다.
~~~
오늘 주제가 바이브 코딩인 만큼, AI에게 물어보겠다.

### [채팅 링크](https://chatgpt.com/share/67f3ee9f-f54c-8006-80f3-e2aace933c53)

대충 보면 뭐 완벽한 시스템이라도 만든 것처럼 떠드는데, 실상을 까보면 예쁜 쓰레기라고 판단할 것이다. 

그야 당연하지, ChatGPT는 내가 뭘 진짜 원하는지 모르고 그냥 내가 써둔 무언가를 분석해서 코드로 나타낸 것 뿐이다.

바이브 코딩을 이렇게 시작하면 AI한테 '아냐아냐 다시 해봐' 하다가 결국 혼내고 있다.

이 패턴이 반복되다 보면, 결국 내가 직접 구현하는 시간 보다 더 오래 걸리는데, 막상 결과물은 마음에 안 드는 상황이 발생할 수 있다.

여태 전체 컨텍스트를 던지고, 잘 못하니까 혼내왔다.

살짝 전략을 바꿔서, 나도 조금은 공부하고 써 봤다.

## 우선, 내 요구사항에 대한 구간을 나누자.
한 컨텍스트 안에서 모든걸 진행했다간

AI가 갑자기 '이 기술스택으로 하니 잘 안되네요, 근데 이걸로 하면 어케 할 수 있음'

하면서 자기 마음대로 별의별 걸 수정해버린다.

사람도 비슷한게, 기획부터 요구사항 명세, 기술스택 선정과 개발 유지보수 모든걸 혼자 하게 되면

정말 많은 갈림길에 놓이고 그때마다 선택하면서 이전의 선택을 롤백해야할 일도 생긴다.

하지만 내가 원하는건 이것은 아니기에, 구간을 나눠서 여러 AI에게 다른 일을 시킬 수 있다.

나는 내가 구현할 부분에 대해 
- 기술스택 선정 단계 
- 요구사항 명세 및 구현 단계
- 세분화 및 테스트 단계 

정도로 나누어서 AI를 사용한다.

## 실제로 한 번 나누어 보면

우선, 이 기능을 만드는데 필요한 기술스택에 대해 고민하고, 이 기술보다 나은 기술이 있는지를 탐구한다.
- 이를 통해, 무중단 배포에는 nginx, 자동 배포 구성에는 shell이 제일 적합하다는 것을 알 수 있었다.

다음으로, 선정한 기술스택을 마음대로 바꾸지 않도록 미리 메모리에 각인시킨 후, 실제 구현을 진행해본다.
- 이전에 의사결정했던 내역을 건드리지 않도록 설계했으니, 결정헀던 기술스택을 최대한 활용하여 어떻게든 만들어낼 수 있더라.

AI는 완벽하지 않으므로, 끊임없는 검증과 테스트가 필요하다.

내가 만들지 않은 코드에 대해 코드 리뷰를 하듯, AI가 만든 코드를 리뷰하고, 테스트하는 것에 의의가 있다.

위 순서를 모두 진행했더니, 이제 대충 무언가 돌아가는 로직이 만들어지게 된다.
~~~
이 기반은 내가 데브옵스 생태계에 익숙한 사람이고, AI 없이도 위 기능을 구현할 수 있는 수준의 지식을 가지고 있기 때문일 것이다.
개인에 맞춘 단계는 얼마든지 세분화할 수 있으니 '내가 확신을 가질 수 있을 때 까지'의 단계를 구성해보는 것을 추천한다.
~~~

위 과정을 따라본 사람들이라면 아마 공감할텐데, 보통은 두번째 파트에서 많은 애로사항을 겪는다.

이는, 만들어진 코드가 '올바른 코드인지' 검증할 수 없기 때문일 것 같다.

## 코드 구현을 지시할 때, 구현해야할 기능을 최대한 잘게 쪼개어 시켜보자.
AI가 만든 상품에 대한 검증과 유지보수도, 결국 인간이 해야하는 상황이 생길 수 밖에 없다.

그를 위해서는 AI가 만들어둔 것을 이해해야 하는데

이를 위해서는 어느 수준의 기능이 있고 어떻게 만들어졌는지 내가 알 필요가 있다.

코드리뷰를 할 때도 비슷하다. 

Application을 다 만들어놓고 리뷰하게 되면

'이 Application에는 문제가 없어요' 라고 보장할 수 있는 사람은 손에 꼽을 것이다.

방대한 양을 리뷰하는 것은, 그만큼 세세하게 보기 힘들기 때문인데

AI도 방대한 업무를 시켜두면 내가 원하는 수준의 구현을 해내지 못하는 일이 많이 생긴다.

이를 방지하려면 정말 세세한 수준으로의 매니징이 필요한데

'그럴거면 내가 구현하지' 생각하게 되더라.

### 살짝 개념을 바꾸어 AI와 페어 프로그래밍을 한다는 관점으로 접근하면
AI가 만든 코드에 대한 신뢰도도 어느정도 생기고, 내가 이어받아서 유지보수를 한다고 해도 진행할 수 있을 것이다.

그래야 이후 검증에서 빠지거나 부족한 부분을 정립할 수 있고, '사람이 보기 쉬운' 코드로 바꿀 수 있다.

## 가장 문제는, 테스트와 검증, 버그에 대한 수정이다.
'자, 너가 원하는 기능 다 만들어줬어!'하고 AI는 기뻐하고 있다.

만들면 뭐할까, 실생활에 적용해야 하는데.

모든 개발자들이 공감하겠지만, 만들어둔 것을 실제로 가져와서 사용할 때는 차원이 다른 문제들에 많이 직면하게 된다.

게다가, 문제들에 직면하지 않더라도 이걸 계획하는 단계에서의 오류를 찾을지도 모른다.

테스트도 AI에 맡겨보려 많은 시도를 했었지만, 아직 '내가 돌려보고 오류 나면 물어보는 것' 보다 좋은 사례를 찾을 순 없었다.

AI에게 '내 컴퓨터에서 테스트환경을 구성하고 테스트하는 법'을 모두 전수해주는 것도 하나의 방법일 것 같은데

'그럴 바에 내가 하지' 마인드로 이건 포기하기로 했다.

내가 즐겨 보는 AI 커뮤니티나 다른 사람들과 토의했을 때에도, 이 부분은 아직 많은 발전이 필요할 것 같았다.

# 내가 느낀 바이브 코딩의 단점
##  우선, 모두가 삽질하는 단계이기에 정해지거나 뭔가 최적화된 방법? 이런게 없다.

'나는 이렇게 쓰고 있어요'의 유즈케이스는 조금씩 보이기 시작했는데, 모든 패러다임의 초기 버전은 항상 이랬을까?

레퍼런스가 없는 무언가를 할 때는 항상 두려움인 것 같다.

## AI가 만든걸 믿을 수 있을까?
좋은 서비스, 좋은 시스템은 '내가 진정으로 믿을 수 있는' 것이라고 생각한다.

AI를 도구로 써서 만들어낸 서비스는 일단 내 이름으로 만들어질텐데

이걸 내가 진정으로 믿을 수 있을까?

AI 할루시네이션이 발생하면 소스코드의 품질은 당연히 바닥을 칠 것이고

그게 아니더라도 '내가 잘 모르는 코드'에 대해서는 쉽사리 믿음을 가질 수 없다.

바이브 코딩에 대한  개발 문화라던가, 파인 튜닝이라던가, 사실 각 문제의 해결방안은 있을 수 있지만

AI가 만든 소스코드는 내 마음이 쉽게 안심할 순 없을 것 같다.

## AI가 만든걸 유지보수할 땐 어떻게 해야하지?
내가 만든 소스코드에 버그가 있다는 제보를 타인에 의해서 받으면

결국 그 소스코드를 보면서 트러블슈팅 하는 것은 내가 될 가능성이 가장 높다.

아니 그렇지 않다고 하더라도, 그 제보에 대한 케어는 내가 해낼 것이니

**결국 내가 소스코드 보게 된다.**

위의 프로세스를 다 따라서 내가 이 코드에 대해서 조금 잘 알게 되더라도

결국 이게 내가 직접 짠 코드는 아니라서 기억력이 바닥을 치게 될 것이다.

그럼 결국 소스코드 다 AI한테 다시 먹이고 트러블슈팅을 요청하는 꼴을 보게 되는데

이는 내가 직접 만들었을 때의 유지보수 시간보다 곱절의 시간은 걸리게 된다.

유지보수하기 쉬운 코드를 보통은 지향하는데, 뭔가 잘못된 것 같다.

## 기능을 만들어준댔지, 예쁘게 만들어준다고는 안 했다.
처음에 완성했던 shell script는 한 파일에 모든 기능을 다 때려박은

이른 바 '1000줄 짜리 코드'였다.

기능은 짰으니 되긴 했는데, 반복되는 코드를 분리한다던가 보기좋게 파일을 나눈다던가

유지보수성 향상을 위한 조치는 단 하나도 되지 않는것을 볼 수 있다.

결국 이걸 나누기 위해서는 내가 직접 지시해야하며

이런 리팩토링을 하면서 'Intellij 없이 메모장만으로 소스코드 리팩토링하기' 가 얼마나 화나는 일인지 간접적으로 겪을 수 있었다.

정리하자면, 유지보수성이 개똥망이다.

AI한테 시키자니 못 믿겠고, 내가 하자니 유지보수가 어렵고

결국 AI가 공부한 걸 바탕으로 내가 마이크로매니징 해서 개발해야 했다.

# 그럼, 어떻게 바이브 코딩을 받아들여야 할까?
바이브 코딩을 실제로 할 것 같은 직군을 몇 개 생각했다.
## 개발자 관점에서
개발자에게 언어와 프레임워크 등의 제약을 없애준 것 만으로도 사실 대단한 업적을 해냈다고 할 수 있다.

이제 개발자는 '내 지식으로 어떻게 만들지?' 보다 '무엇을 만들지?'에 조금 더 집중할 수 있다.

내가 원하고자 하는 기능을 만들 때 AI의 도움을 받으면서 만들 수 있다.

쉽게, 내가 해야할 일을 아주 조금씩 나눠서 AI들에게 시킬 수 있으니

나에게 생기는 부하를 어느정도 줄여줄 수 있는 것도 사실일 것이다.
## 테스터 관점에서
내가 운영 업무를 하면서 테스트를 많이 해야했을 때는, '소스코드를 100% 파악하고 테스트를 해본다'에 대한 어려움이 있었다.

주어진 시간 안에 꽤나 많은 테스트를 해야만 하고, 이후 반영까지 진행해야 하기에 소스코드 파악을 제대로 못한 적도 꽤 있었던 것 같은데

이럴 때 AI에게 소스코드 요약, 에러가 날 만한 부분 검증 등 내가 놓칠 수 있는 부분들을 어느정도 보완해줄 수 있을 것 같다.

CI 때 웬만한 건 이미 되겠지만, 화이트박스 테스트도 어느정도 수행할 수 있을 것이라 생각하고는 있다.

물론, 소스코드 반출은 중대한 보안 위반이기에, 충분한 보안 요건 검토가 필요할 것이다.

## 기획자 관점에서
내가 써놓은 요구사항을 소스코드에서 제대로 나타내고 있는지 검증하는 과정은 아마 없었던 것 같다.

대부분 테스트케이스로 나타냈을 것인데, 소스코드를 분석할 수 있는 친구가 내 부하로 있으니

어느정도 내 문맥과 일치하는지 검증도 가능할 것으로 보고 있다.

요구사항에 대한 테스트케이스 작성하는 것도 꽤 힘든 업무에 속할 것 같은데

AI에게 시켜봤더니 어느 정도는 해내는 거 같았다.

물론, 개발자가 어떻게 만드냐에 따라서 테스트케이스는 많이 바뀔 수 있으니, 미리 컨벤션을 맞춰 두면 활용할 수 있을 것 같다.

## 비개발자 관점에서
사실 모두에게 해당하는 내용일 거 같은데,

'반복되는 짜증나는 일'들은 웬만해서는 자동화가 가능했다.

이를 위한 과정을 풀어낼 때 많은 방법이 있겠지만

이제 '내가 바이브 코딩으로 만든 프로그램'도 하나의 해결 방법이 될 수 있음을 알게 될 것이다.

"하... 귀찮은데 이거 어떻게 해결할 방법이 없나..?" 하는 말 되게 많이 듣는데

이제 AI가 해결방안을 조금은 제안할 수 있게 될 것 같다.
![img_1.png](img_1.png)
# 마치며
위의 과정을 어느정도 정리할 수 있는 수준이 될 때까지 정말 많은 시간이 걸린 것 같다.

정말 많은 삽질을 했는데, 아마 현 세대의 개발자 거의 전부가 나랑 비슷한 삽질을 동시에 하고 있지 않을까 한다.

위에서 보았다 시피, 아직 바이브 코딩으로 개발 '업무'를 수행하기에는 무리가 좀 있다.

개발자가 코드를 만들기만 하고 끝이라면 괜찮은데, 우리는 미래의 유지보수도 생각해야한다는 것을 AI는 모른다는 것이 어느 한계점인 것 같다.

바이브 코딩은 객체지향이나 절차지향 같이 뭔가 이론적으로 정할 수 있는 영역이 아니라

'모든걸 알고 있지만 시키는 일만 하는 사람'과 대화하는 느낌이라 조금 더 머리에 넣기 힘든 이론인 것 같다.

결국 인류는 발전하고, 우리가 편해지기 위해 모두가 노력할테니

바이브 코딩이라는 패러다임이 얼마나 성장할지 기대한다.