# 컴퓨터의 대화를 이해해보자: HTTP

지금 보고 있는 이 화면도, HTTP://로 시작하는 어떤 페이지로 되어 있습니다.

서버에서 통신할 때에도, Web에서 화면을 보여줄 때도 사용합니다.

우리가 살아가는데 아마, HTTP는 정말 어디에서도 보이는 것 같습니다.

이는 '컴퓨터가 대화하기 위한 수단'으로 사용되고 있기 때문인데

컴퓨터끼리만 대화하고 저한테는 결과만 보여주니

뭔가 치사하고 그렇습니다.

한국인 앞에서 영어로만 얘기하는 느낌일까요?

오늘은 컴퓨터가 대화하는 방법 중 가장 유명한 방법인 HTTP에 대해 알아보도록 하겠습니다.

![img_2.png](img_2.png)

그래도 개발자 하려면 들어야겠죠.

# HTTP (HyperText Transfer Protocol)

HTTP는 웹에서 가장 널리 사용되는 프로토콜입니다. 

주로 웹 브라우저와 웹 서버 간의 통신에 사용되고, 서버 간 통신(REST API)에도 가장 활발히 사용되는 프로토콜 중 하나입니다.

지금 보고 있는 화면도 이 프로토콜을 통해 얻은 결과물 중 하나로, 

client가 HTTP Protocol로 요청을 server에 보내면 그에 상응하는 응답을 받을 수 있습니다.

![img_3.png](img_3.png)
## HTTP의 발전

### HTTP/0.9
우리 눈에 보이는 가장 최초는 아마 HTTP/0.9일 것입니다.

초기에 제안되었던 HTTP/0.9는 1991년에 최초로 등장하였고, 현재에도 꽤나 큰 폭으로 남아있습니다.

이 때 당시에는 GET method의 요청만 지원하는데

서버 간 통신을 할 때에는 HTTP보단 보통 Socket 형식을 많이 사용했었고, 웹 페이지 호출을 겨냥했기 때문입니다.

#### 연동하는 예시를 상상해본다면
```
URL을 설정하고,
요청을 보내고, 
응답값을 알맞게 사용합니다.
```
뭔가 빠진 것 같지만, 기본적인 통신에 사용할 수 있다는건 알겠습니다.

### HTTP/1.0

1996년에 등장한 HTTP/1.0은 HTTP/0.9의 제한된 기능을 크게 개선했습니다.

가장 큰 변화는 헤더(Header)의 도입으로, 메타데이터를 전송할 수 있게 되었습니다.

이를 통해 콘텐츠 타입, 인코딩, 상태 정보 등을 주고받을 수 있게 되었죠.

또한 GET 외에도 POST와 HEAD 등 여러 메소드가 추가되어 더 다양한 요청이 가능해졌고,

상태 코드(Status Code)가 도입되어 서버의 응답 상태를 명확히 알 수 있게 되었습니다.

HTTP/1.0에서의 내용 대부분이, 현재 우리에게 가장 크게 다가오는 부분이라고 볼 수 있습니다.

#### 왜 나왔을까?
정적 웹페이지의 형태가 HTML뿐만 아니라 이미지, 스크립트 등 다양해지고 통신량이 늘어나면서 더 많은 기능이 필요했기에,

HTTP/0.9의 제한된 기능을 뛰어넘어 다양한 통신 방법을 지원할 필요가 있었습니다.

#### 연동하는 예시를 상상해본다면
```
URL을 설정하고, 
Method를 설정하고, 
(선택적)Header, Body를 구성한 다음 
요청을 보내고, 
전달받은 응답에 대한 Status를 확인한 후
응답 Header(선택적)와 Body를 알맞게 사용합니다.
```
이제, 우리가 아는 정통적인 HTTP Protocol 통신 방식이 보이게 되었습니다.

### HTTP/1.1

1997년에 출시된 HTTP/1.1은 기존의 HTTP/1.0을 한층 더 발전시켰습니다.

한 마디로 요약하자면, 성능 개선과 Header 필수화로 생각하고 있습니다.

가장 큰 특징으로는 영구 연결(Persistent Connection)의 도입을 꼽을 수 있습니다.
이전 버전에서는 매 요청마다 연결을 새로 맺어야 했지만, 이제는 한 번 맺은 연결을 여러 요청에 재사용할 수 있게 되었죠.

예를 들어, 웹 페이지를 로드할 때를 생각해보면

**HTTP/1.0의 연결 방식**
- 이미지 1 요청 -> TCP 연결 -> 응답 -> 연결 종료
- 이미지 2 요청 -> 새 TCP 연결 -> 응답 -> 연결 종료
- 이미지 3 요청 -> 또 새 TCP 연결 -> 응답 -> 연결 종료

**HTTP/1.1의 연결 방식**

- TCP 연결 한 번 수립
- 이미지 1 요청 -> 응답
- 이미지 2 요청 -> 응답
- 이미지 3 요청 -> 응답
- 모든 요청 완료 후 연결 종료

이를 통해 연결 수립에 드는 시간과 리소스를 크게 절약할 수 있게 되었습니다.
Connection 헤더를 통해 "keep-alive" 설정으로 연결을 유지하거나 "close"로 즉시 종료할 수 있습니다.

또한 파이프라이닝(Pipelining)이라는 기능이 추가되어, 응답을 기다리지 않고도 여러 요청을 연속해서 보낼 수 있게 되었습니다. 

파이프라이닝은 마치 컨베이어 벨트처럼 요청을 순차적으로 처리하는 방식으로,

Request1 -> Request2 -> Request3을 보내고 Response1 -> Response2 -> Response3을 순서대로 받을 수 있습니다. 

이는 각 요청마다 연결을 맺고 끊는 오버헤드를 줄여 전체적인 성능을 향상시켰습니다.

- HTTP/1.0에서는
  - Request1 -> Response1 완료 후 -> Request2 -> Response2 완료 후 -> Request3 -> Response3

- HTTP/1.1 파이프라이닝 
  - Request1 -> Request2 -> Request3 -> Response1 -> Response2 -> Response3

Host 헤더가 필수가 되어 하나의 IP 주소에서 여러 도메인을 호스팅하는 것이 가능해졌고,

캐시 제어 기능(Cache-Controll, ETag 등)도 크게 개선되어 네트워크 자원을 더욱 효율적으로 사용할 수 있게 되었습니다.

이러한 HTTP/1.1의 개선사항들은 현재까지도 웹의 근간을 이루고 있으며,

대부분의 웹 서비스들이 이 버전을 기본으로 사용하고 있습니다.

#### 왜 나왔을까?

HTTP/1.0의 성능 문제와 제한된 기능을 개선하기 위해 등장했습니다.

특히 매 요청마다 새로운 연결을 맺어야 하는 오버헤드와
표준화되지 않은 헤더 사용으로 인한 호환성 문제를 해결하고자 했습니다.

또한 웹의 급속한 성장으로 인해 캐싱, 프록시, 가상 호스팅 등
새로운 기능들에 대한 요구가 증가하면서 이를 표준화할 필요성이 대두되었습니다.

#### 연동하는 예시를 상상해본다면
```
URL을 설정하고, 
Method를 설정하고, 
Header, Body를 구성한 다음 
요청을 보내고, 
전달받은 응답에 대한 Status를 확인한 후
응답 Header와 Body를 알맞게 사용합니다.
```
HTTP/1.0과 크게 다를 바 없지만

성능 측면에서 크게 개선되었고 있는지 없는지 항상 검증해야했던 Header가 항상 존재하도록 수정되었습니다.

드디어, 우리가 자주 사용하는 HTTP를 보게 되었습니다.
### HTTP/2.0

2015년에 등장한 HTTP/2.0은 웹의 성능을 획기적으로 개선했습니다.

가장 큰 특징은 멀티플렉싱(Multiplexing)입니다. 하나의 TCP 연결에서 여러 요청과 응답을 동시에 처리할 수 있게 되었죠.
이전 버전의 파이프라이닝이 가진 순차 처리의 한계를 극복했습니다.

- HTTP/1.1 파이프라이닝
   - Request1 -> Request2 -> Request3 -> Response1 -> Response2 -> Response3
   - 앞선 요청의 응답이 지연되면 뒤의 모든 요청이 지연됨 (Head-of-Line Blocking)

- HTTP/2.0 멀티플렉싱
   - 모든 요청과 응답이 독립적으로 처리됨
   - Request1, Request2, Request3를 동시에 보내고 준비되는 대로 응답 수신
   - 특정 요청의 지연이 다른 요청에 영향을 주지 않음

또한 헤더 압축을 통해 중복되는 헤더 정보를 효율적으로 전송하고,

서버 푸시 기능으로 클라이언트가 요청하기 전에 필요한 리소스를 미리 전송할 수 있게 되었습니다. 

예를 들어, 브라우저가 HTML 페이지를 요청하면 서버는 해당 페이지와 함께 CSS, JavaScript 파일 등

페이지 렌더링에 필요한 리소스들을 선제적으로 보낼 수 있어 페이지 로딩 속도가 크게 개선되었습니다.

#### 왜 나왔을까?

웹 환경이 점점 복잡해지면서 기존 HTTP/1.1의 한계가 드러났습니다.

특히 모바일 기기의 보급으로 인한 네트워크 지연 문제와
웹 페이지의 리소스 증가로 인한 성능 저하가 주요 이슈였습니다.

이를 해결하기 위해 Google이 SPDY 프로토콜을 개발했고,
이것이 HTTP/2.0의 기반이 되어 표준화되었습니다.

#### 연동하는 예시를 상상해본다면
여기서부터는 이전처럼 한 번에 보일만한 예시는 어렵게 되었습니다.

현업에서 이제 도입이 시작되고 있으며, 이렇다할 예시를 한 번에 보이기 복잡한 사유도 있습니다.

하지만 어떻게든 만들어보자면
```
URL을 설정하고,
Method를 설정하고,
(선택적)Header, Body를 구성한 다음

HTTP/2 스트림을 생성해 요청을 보내며,
동일한 연결 상에서 여러 요청을 병렬로 보낼 수 있습니다.

서버로부터 전달받은 응답 스트림에 대해 
Status를 확인하고,
응답 Header(선택적)와 Body를 프레임 단위로 수신합니다.

필요하면 서버 푸시(PUSH_PROMISE) 프레임도 받아
추가 리소스를 캐시에 저장할 수 있습니다.
```
정도로 정리할 수 있을 것 같습니다.

대표적인 예시로 gRPC를 들 수 있는데,

gRPC같은 예시는 추후 새로운 글로 찾아뵐 수 있도록 하겠습니다.

### HTTP/3.0

2022년에 표준화된 HTTP/3.0은 기존 TCP 기반에서 벗어나 QUIC이라는 새로운 전송 프로토콜을 사용합니다.

QUIC은 UDP를 기반으로 하여 연결 설정 시간을 대폭 단축했고,
각 스트림이 독립적으로 작동하여 한 스트림의 손실이 다른 스트림에 영향을 주지 않습니다.

주요 특징으로는
- 연결 설정 시간 감소 (0-RTT 또는 1-RTT)
- 향상된 오류 복구 능력
- 네트워크 전환 시에도 연결 유지 (Connection Migration)
- TLS 1.3 통합으로 향상된 보안

정도로 볼 수 있을 것 같습니다.

#### 왜 나왔을까?
HTTP/2도 멀티플렉싱이 되지만, TCP 기반이라 패킷 하나만 손실돼도 전체 스트림이 지연되는 문제가 있었어요.

HTTP/3는 **QUIC(UDP 기반)**을 사용해서 스트림 간 독립성을 확보하고, 지연 없는 복구, 빠른 연결, 내장된 보안을 제공합니다.

#### 연동하는 예시를 상상해본다면

HTTP/3.0도 복잡한 내부 동작으로 인해 간단한 예시로 표현하기는 어렵지만, 개념적으로 보자면
```
URL을 설정하고,
Method와 Header, Body를 구성합니다.

QUIC 기반의 연결을 시도하며,
TLS 1.3으로 자동 보안 핸드셰이크가 함께 진행됩니다.

QUIC 스트림을 생성해 요청을 보냅니다.
(HTTP/3는 QUIC 위의 멀티 스트림 구조)

서버의 응답은 스트림 단위로 수신되며,
패킷 손실이 있어도 다른 스트림은 영향을 받지 않습니다.

응답 상태, 헤더, 바디를 해석하고 사용합니다.
```
정도로 볼 수 있을 것 같습니다.

아쉽게도, Server Side 에서 HTTP/3.0 Protocol의 구현은 아직 뚜렷한 방향을 찾지 못했습니다.

많이 쓰이지 않기도 하고, 대부분 Rust나 C에서 구현한 Plugin을 이용하는 방향으로 진행되는 경향입니다.

SpringBoot에 이를 지원하는 Library를 만든다면, 사람들이 사용할까요?

### 정리
HTTP의 변천사에 따라, 기능 명세를 간단히 정리해보았습니다.

| 항목               | HTTP/0.9              | HTTP/1.0              | HTTP/1.1              | HTTP/2                  | HTTP/3                   |
|--------------------|------------------------|------------------------|------------------------|--------------------------|---------------------------|
| 발표 시기            | 1991년                 | 1996년                 | 1997년                 | 2015년                   | 2022년 (RFC 정식 승인)     |
| 기반 프로토콜         | TCP                    | TCP                    | TCP                    | TCP                      | **QUIC (UDP 기반)**        |
| 지원 메서드           | GET만 지원              | GET, POST 등 일부       | 대부분 지원              | 동일                      | 동일                        |
| 상태 코드 / 헤더 지원  | ❌ 없음                  | ✅ 기본 지원              | ✅ 확장된 헤더/캐싱 등       | ✅ 바이너리 헤더 (HPACK)     | ✅ 바이너리 헤더 (QPACK)      |
| 멀티플렉싱            | ❌ 없음                  | ❌ 없음                  | ❌ 없음                  | ✅ 다중 스트림 처리          | ✅ 다중 스트림 + 독립 처리     |
| 연결 재사용           | ❌ 요청마다 새 연결        | ❌ 기본은 단일 요청         | ✅ Keep-Alive 지원        | ✅ 연결 유지 + 병렬 전송      | ✅ 연결 유지 + 병렬 전송       |
| 헤드 오브 라인 블로킹 | ❌ 단일 요청             | ✅ 발생 가능              | ✅ 발생 가능              | ✅ TCP 수준에서 발생         | ❌ 제거됨 (QUIC 덕분)         |
| TLS 내장             | ❌ 없음                  | ❌ 외부 SSL 필요          | ❌ 외부 SSL 필요          | ❌ (TLS 1.2/1.3 사용 가능)   | ✅ **TLS 1.3 내장 필수**       |
| 패킷 손실 시 영향       | 전체 연결 종료             | 전체 연결 지연             | 전체 연결 지연             | 전체 연결 지연               | ✅ **스트림 단위 지연만 발생** |
| 서버 푸시            | ❌ 없음                  | ❌ 없음                  | ❌ 없음                  | ✅ 지원                    | ❌ (대부분 브라우저에서 제거됨) |

아래의 내용에는 제가 공부하면서 궁금했던 것들의 질의응답을 간단히 정리해 보았습니다.

![img_4.png](img_4.png)

## 최신 HTTP 나오면 바로바로 바꾸면 되잖아. 왜 안 바꿔?
라고 생각할 수 있을 것입니다.

모두가 공감하겠지만, 나온다고 바로바로 바꿨다가 이슈가 발생하면 크나큰 손실이기에

새로운 무언갈 적용할 때에는 충분한 검토가 필요합니다.

간략히, 새로운 프로토콜 같은 걸 적용하기 어려운 이유를 정리했습니다.
### 1. 기반 인프라가 바뀌어야 함
- HTTP/1.x → 2: TCP 기반이므로 기존 인프라와 크게 다르지 않음 → 상대적으로 쉽게 채택 
- HTTP/3: UDP 기반의 QUIC 프로토콜 필요 → 완전히 다른 전송 계층 
  - 방화벽, 프록시, 보안 장비들이 UDP 막고 있을 수도 있음 
  - 로드밸런서나 CDN이 HTTP/3를 지원해야만 실제 사용 가능

> 단순히 앱 코드만 바꾸면 되는 게 아님. 네트워크 인프라 전체가 지원해야 함

### 2. 클라이언트와 서버 모두가 지원해야 함
- HTTP는 양방향 약속 
  - 클라이언트가 HTTP/3 요청을 해도, 서버가 지원 안 하면 fallback 
  - 서버가 HTTP/3만 열어도, 브라우저가 지원 안 하면 접속 불가

> 이용자들이 수익을 창출하는 만큼, 이용자들에게 맞는 서비스를 제공해야 함.
> 
> 이를 위해서라면, 이용자들이 사용하지 않는 기술을 도입할 수는 없음.

### 3. 보안 및 운영 리스크
- 새 프로토콜은 초기에는 버그, 취약점 발생 가능성 
- 예: QUIC 초기 구현 이슈, handshake 문제, MTU 문제 
- 시스템 전체에 도입했다가 장애 나면 감당 어려움

### 4. 레거시 호환, 로깅/모니터링 이슈
- HTTP/1.1 기반으로 짜여 있는 로깅 시스템, APM, WAF, API Gateway들이 HTTP/2, 3의 프레임 기반 구조를 제대로 해석 못함
- 특히 HTTP/3는 패킷 구조 자체가 달라서 툴 전면 교체 필요

### 5. 전환하는 비용 대비 실제 뚜렷한 이득을 보기 어려움
- 단순 CRUD API만 돌리는 서비스는 HTTP/1.1로도 충분히 빠름 
- HTTP/2/3의 장점은 멀티플렉싱, 지연 최소화, 스트리밍 등인데 이런 게 필요 없는 시스템이라면 도입 비용 > 이득

## HTTP의 보안?
HTTP Protocol은 대화하는 방법이지, 이 대화를 안전하게 보장해주진 않습니다.

친구에게 대화할 때, 옆에 서있던 사람이 들을 수 있듯, 지나가는 다른 사용자가 이 내용을 볼 수 있습니다.

이를 보완하기 위한 방법으로 HTTPS를 들 수 있습니다.

HTTPS에 대한 내용 또한 방대하므로, 이 내용은 별도의 주제로 분리하여 게시글로 찾아뵐 수 있도록 하겠습니다.

# Cons.
역사 공부가 제일 힘들지만, 과거를 공부하며 '이 때의 소스코드는 그래서 그랬구나'라는 인식을 할 수 있게 됩니다.

Legacy는 갈아치워야 할 옛것이 아닌, 예전부터 굳건히 버텨온 견고한 무언가라는 사실을 다시 한 번 깨닫습니다.

앞으로의 미래를 위해 개선되는 것은 맞지만, 개선을 위해 고려해야 할 사항은 한둘이 아님을 복기하며 마칩니다. 

~~이제 HTTP Protocol로 어디가서 아는 척좀 하겠습니다.~~