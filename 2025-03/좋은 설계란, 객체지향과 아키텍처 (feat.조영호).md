# 좋은 설계란, 객체지향과 아키텍처 (feat.조영호)

> "객체지향적으로 설계해야 합니다.", "좋은 아키텍처를 만들어야 합니다."    
> 개발을 하면서 한 번쯤 들어봤을 말이지만, 막상 개발을 시작하면 좋은 설계가 무엇인지 감을 잡기가 쉽지 않죠.
> 
> 설계를 신경 써서 했다고 생각했는데 유지보수가 어려워지고, 협업 과정에서 코드 일관성이 무너지는 경험을 해보신 적 있으신가요?  
> 어떻게 객체지향 설계와 애플리케이션 아키텍처를 적절하게 적용할 수 있을지 함께 알아봅시다.

---

### 대상 독자
- 객체지향 설계와 애플리케이션 아키텍처를 실무에 잘 적용하고 싶은 분

### 읽는 데 걸리는 시간
- 약 10분

### 목차

# Table of Contents (TOC)

- [1. 객체지향 설계와 애플리케이션 아키텍처, 뭐가 다를까요?](#1-객체지향-설계와-애플리케이션-아키텍처-뭐가-다를까요)

- [2. 객체지향 설계란 무엇인가요?](#2-객체지향-설계란-무엇인가요)
  - [2-1. 객체지향의 역사와 여전히 중요한 이유](#2-1-객체지향의-역사와-여전히-중요한-이유)
  - [2-2. 객체지향 설계의 핵심 원칙: SOLID](#2-2-객체지향-설계의-핵심-원칙-solid)

- [3. 애플리케이션 아키텍처란 무엇인가요?](#3-애플리케이션-아키텍처란-무엇인가요)
  - [3-1. 애플리케이션 아키텍처의 개념](#3-1-애플리케이션-아키텍처의-개념)
  - [3-2. 애플리케이션 내부 아키텍처 패턴](#3-2-애플리케이션-내부-아키텍처-패턴)
    - [1) 레이어드 아키텍처 (Layered Architecture)](#1-레이어드-아키텍처-layered-architecture)
    - [2) 헥사고날 아키텍처 (Hexagonal Architecture)](#2-헥사고날-아키텍처-hexagonal-architecture)
    - [3) 클린 아키텍처 (Clean Architecture)](#3-클린-아키텍처-clean-architecture)
  - [3-3. 시스템 아키텍처 패턴](#3-3-시스템-아키텍처-패턴)
    - [1) 모놀리식 아키텍처 (Monolithic Architecture)](#1-모놀리식-아키텍처-monolithic-architecture)
    - [2) 마이크로서비스 아키텍처 (Microservices Architecture, MSA)](#2-마이크로서비스-아키텍처-microservices-architecture-msa)
    - [3) 서비스 지향 아키텍처 (Service-Oriented Architecture, SOA)](#3-서비스-지향-아키텍처-service-oriented-architecture-soa)
  - [3-4. 아키텍처 간의 관계와 발전 과정](#3-4-아키텍처-간의-관계와-발전-과정)

- [4. 마무리 - 조영호님의 강의를 듣기 전에](#4-마무리---조영호님의-강의를-듣기-전에)


---

# 1. 객체지향 설계와 애플리케이션 아키텍처, 뭐가 다를까요?

객체지향이 소프트웨어 개발의 표준이 된 지 오래되었음에도 불구하고, 우리는 여전히 "객체지향이란 무엇인가?"라는 질문에 정확히 답하지 못하고 있습니다.  
객체지향을 제대로 이해하지 못한 채 클래스 중심의 설계에만 집중하거나,  
코드의 재사용성과 유지보수성을 높이기보다는 단순히 상속과 캡슐화를 적용하는 데 그치는 경우가 많습니다.

객체지향은 단순히 클래스를 정의하는 것이 아니라, 객체가 협력하며 문제를 해결하는 방식입니다.  
객체를 독립적인 존재로 바라보는 것이 아니라, 서로 역할과 책임을 나누고 협력하는 공동체의 일원으로 설계하는 것이 핵심이죠.

그렇다면 애플리케이션 아키텍처는 무엇이 다를까요?  
객체지향 설계가 코드 레벨에서 객체 간의 협력을 정의하는 과정이라면,  
애플리케이션 아키텍처는 이 객체들이 모여 전체 시스템을 이루는 방식을 설계하는 과정입니다.  
즉, 객체지향 설계는 코드 내부의 구조를 고민하는 것이고, 아키텍처는 패키지, 모듈, 도메인, 계층을 어떤 기준으로 구성할지 고민하는 것입니다.

다가오는 3월 말, '객체지향의 사실과 오해'와 '오브젝트'의 저자 조영호 님이 다날을 방문하여 강연을 진행할 예정인데요!  
그 전에 이번 글을 통해 객체지향 설계와 애플리케이션 아키텍처의 개념을 정리하고,  
강의를 더 깊이 있게 이해할 수 있도록 준비해보시면 좋겠습니다. 😎

---

# 2. 객체지향 설계란 무엇인가요?

## 2-1. 객체지향의 역사와 여전히 중요한 이유

객체지향 프로그래밍(OOP)은 1960년대 시뮬라(Simula) 언어에서 처음 등장했습니다.  
이후 Smalltalk, C++, Java 같은 언어들이 객체지향 개념을 발전시켜 왔으며,  
오늘날에도 Java, Python, Kotlin, TypeScript 등 다양한 언어에서 객체지향 패러다임을 적극적으로 활용하고 있습니다.

최근 마이크로서비스 아키텍처, 클라우드 네이티브, 함수형 프로그래밍 같은 개념이 주목받고 있지만,  
여전히 객체지향 설계는 소프트웨어 개발의 중심적인 원칙으로 자리 잡고 있습니다.

그 이유는 다음과 같습니다.

- **현실 세계를 소프트웨어로 자연스럽게 모델링할 수 있다**
  - 객체는 현실 세계의 개체(Entity)를 추상화한 개념이므로, 실제 문제를 해결하는 데 직관적이고 효과적입니다.
  - 예를 들어, "자동차"라는 객체가 "운전하다"라는 메서드를 가지고 있다면, 이는 현실 세계의 개념을 그대로 코드로 옮긴 것입니다.

- **코드를 유연하게 확장하고 재사용성을 높일 수 있다**
  - 캡슐화, 다형성, 상속 같은 개념을 활용하면 중복을 줄이고, 기존 코드를 재사용할 수 있습니다.
  - 특히, 다형성(Polymorphism)을 활용하면 새로운 기능을 추가할 때 기존 코드를 수정하지 않고 확장할 수 있습니다.

- **유지보수성과 확장성이 높은 설계를 할 수 있다**
  - 현실 세계에서도 각 역할이 분리되어 있듯이, 객체지향 설계를 적용하면 시스템이 독립적인 역할을 가진 여러 객체로 나뉘어 관리됩니다.
  - 이를 통해 특정 기능을 수정할 때 전체 시스템을 변경할 필요가 줄어들고, 기능 추가도 훨씬 용이해집니다.

이처럼 객체지향 설계는 단순히 "클래스를 정의하는 방식"이 아니라,  
소프트웨어를 현실 세계처럼 유기적으로 설계하고 관리하는 데 필수적인 개념입니다.

## 2-2. 객체지향 설계의 핵심 원칙: SOLID

객체지향 설계를 효과적으로 적용하기 위해서는 SOLID 원칙을 이해하는 것이 중요합니다.  
SOLID는 유지보수성과 확장성을 고려한 객체지향 설계의 핵심 원칙으로,  
소프트웨어의 유연성, 재사용성, 가독성을 높이는 데 도움을 줍니다.

- **단일 책임 원칙 (SRP: Single Responsibility Principle)**
  - 하나의 클래스는 하나의 책임만 가져야 합니다.
  - 여러 기능을 하나의 클래스에서 처리하면 수정할 때 예상치 못한 오류가 발생할 수 있습니다.
  - 예제: "사용자 정보 관리"와 "파일 저장"을 같은 클래스에서 처리하는 대신, 각각 `UserManager`와 `FileStorage` 클래스로 분리하는 것이 좋습니다.

- **개방-폐쇄 원칙 (OCP: Open/Closed Principle)**
  - 소프트웨어 요소(클래스, 모듈 등)는 확장에는 열려 있어야 하지만, 수정에는 닫혀 있어야 합니다.
  - 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있어야 합니다.
  - 예제: `PaymentProcessor` 클래스에서 새로운 결제 방식을 추가할 때, 기존 코드를 변경하지 않고 새로운 `PayPalPayment`, `CreditCardPayment` 클래스를 추가할 수 있도록 인터페이스를 활용하는 방식이 있습니다.

- **리스코프 치환 원칙 (LSP: Liskov Substitution Principle)**
  - 하위 클래스는 상위 클래스의 기능을 온전히 대체할 수 있어야 합니다.
  - 부모 클래스의 객체를 사용하는 곳에서 자식 클래스를 넣어도 프로그램이 정상적으로 동작해야 합니다.
  - 예제: `Rectangle`을 상속한 `Square`가 있다면, `setWidth()`와 `setHeight()`를 각각 호출할 때 일관된 동작을 보장해야 합니다.

- **인터페이스 분리 원칙 (ISP: Interface Segregation Principle)**
  - 클라이언트가 사용하지 않는 메서드에 의존하지 않도록, 인터페이스를 작게 유지해야 합니다.
  - 하나의 거대한 인터페이스보다는, 필요한 기능만을 제공하는 여러 개의 작은 인터페이스로 나누는 것이 좋습니다.
  - 예제: `MultiFunctionPrinter`라는 인터페이스에 `scan()`, `print()`, `fax()` 기능이 모두 있다면,  
    스캐너 기능만 필요한 클래스도 불필요한 `print()`와 `fax()` 메서드를 구현해야 합니다.  
    이를 해결하기 위해 `Scanner`, `Printer`, `FaxMachine` 인터페이스를 각각 나누는 것이 바람직합니다.

- **의존성 역전 원칙 (DIP: Dependency Inversion Principle)**
  - 상위 수준의 모듈이 하위 수준 모듈에 직접 의존하면 안 되며, 인터페이스를 통해 의존성을 관리해야 합니다.
  - 즉, 구현체가 아니라 추상화된 개념(인터페이스)에 의존하도록 설계해야 합니다.
  - 예제: `PaymentService`는 `CreditCardPayment`가 아니라 `Payment` 인터페이스에 의존하므로,  
    나중에 `PayPalPayment` 같은 새로운 결제 방식을 추가해도 기존 코드를 수정하지 않고 확장할 수 있습니다.

이처럼 객체지향 설계를 할 때 SOLID 원칙을 적용하면 확장성과 유지보수성이 뛰어난 소프트웨어를 만들 수 있습니다.  
단순히 객체를 정의하는 것이 아니라, 각 객체가 어떤 역할을 수행해야 하는지, 어떻게 협력해야 하는지를 고민하는 것이 객체지향의 핵심입니다.

---

# 3. 애플리케이션 아키텍처란 무엇인가요?

## 3-1. 애플리케이션 아키텍처의 개념

애플리케이션 아키텍처는 소프트웨어를 어떤 방식으로 설계하고 구성할 것인지 결정하는 패턴과 원칙을 의미합니다.  
"애플리케이션 내부의 코드와 모듈을 어떻게 구조화할 것인가?", "서비스 간 관계를 어떻게 정의할 것인가?"를 고민하는 과정입니다.

소프트웨어 아키텍처는 크게 두 가지 관점에서 나눌 수 있습니다.

1️⃣ **애플리케이션 내부 아키텍처**
- 하나의 애플리케이션 내부에서 코드를 어떻게 구성할 것인지를 설계
- 예시: 레이어드 아키텍처, 헥사고날 아키텍처, 클린 아키텍처 등

2️⃣ **시스템 아키텍처**
- 여러 애플리케이션을 조합하여 어떤 방식으로 서비스 간 관계를 구성할 것인지를 설계
- 예시: 마이크로서비스 아키텍처, 서비스 지향 아키텍처(SOA), 이벤트 기반 아키텍처 등

각 관점에서 대표적인 아키텍처 패턴을 살펴보겠습니다.

## 3-2. 애플리케이션 내부 아키텍처 패턴

### **1) 레이어드 아키텍처 (Layered Architecture)**

가장 전통적인 아키텍처로, 애플리케이션을 기능별 계층(Layer)으로 나누는 방식입니다.

**구성:**
- `Presentation Layer (UI, Controller)` → 사용자 요청 처리
- `Application Layer (Service)` → 비즈니스 로직 수행
- `Data Access Layer (Repository, DAO)` → 데이터 저장 및 조회

**특징:**  
✅ 단순하고 익숙한 구조로, 대부분의 애플리케이션에서 사용됨  
✅ 각 계층이 분리되어 있어 역할이 명확함  
⚠️ 계층 간 강한 결합이 발생하면 변경이 어려워질 수 있음

**적용 사례:**
- 전통적인 웹 애플리케이션 (Spring MVC, Django, ASP.NET 등)

>📌 그럼 Spring MVC는 무조건 레이어드 아키텍처인가요?  
> Spring MVC 자체가 레이어드 아키텍처를 강제하지는 않지만, 기본적으로 레이어드 아키텍처를 적용하는 경우가 많습니다.  
> 아키텍처 설계 기준에 따라 헥사고날, 클린 아키텍처 등과도 얼마든지 조합이 가능합니다.

### **2) 헥사고날 아키텍처 (Hexagonal Architecture, Ports & Adapters)**
 
비즈니스 로직(Core Domain)을 중심에 두고, 외부 시스템(데이터베이스, API 등)과의 의존성을 최소화하는 구조입니다.  
이 아키텍처의 핵심 개념은 "애플리케이션의 핵심 로직은 변하지 않아야 하고, 외부 요소는 언제든 교체할 수 있어야 한다"는 것입니다.

**구성:**
- `Core Domain (비즈니스 로직)`
- `Ports (입출력 인터페이스)` → 비즈니스 로직과 외부 시스템을 분리하는 역할
- `Adapters (구현체)` → 포트를 통해 실제 데이터베이스, API 등의 구현이 이루어짐

**특징:**  
✅ 외부 의존성을 최소화하여 유지보수성과 테스트 용이성 증가  
✅ 애플리케이션이 특정 프레임워크나 기술 스택에 종속되지 않음  
⚠️ 설계 복잡도가 증가할 수 있음

**적용 사례:**
- 물류 서비스, 결제 시스템처럼 외부 시스템과의 통합이 잦은 애플리케이션

### **3) 클린 아키텍처 (Clean Architecture)**

클린 아키텍처는 비즈니스 로직을 최우선으로 보호하고, 외부 요소(UI, 데이터베이스, 프레임워크 등)의 영향을 최소화하는 구조입니다.
핵심 도메인 로직이 외부 기술에 의존하지 않도록 설계하는 것이 목표입니다.

>📌 헥사고날과 클린 아키텍처는 뭐가 다른 건가요?  
> 클린 아키텍처와 헥사고날 아키텍처는 비즈니스 로직을 외부 요소로부터 보호한다는 공통 목표를 가지고 있습니다.  
> 하지만 접근 방식에 차이가 있습니다.  
> 
> 클린 아키텍처는 비즈니스 로직(Use Case)을 중심에 두고, 모든 의존성이 안쪽으로 흐르게 하는 방식,  
> 헥사고날 아키텍처는 도메인 로직을 포트와 어댑터로 격리하여 외부 시스템과의 결합을 줄이는 방식이죠.

**구성:**
- `Entities (도메인 모델)` → User, Order, Payment 등 비즈니스의 핵심 개념을 정의
- `Use Cases (비즈니스 규칙)` → 비즈니스 로직을 실행하는 계층
- `Interface Adapters (프레젠테이션 & 데이터 변환)` → 유스케이스와 외부 인터페이스 간 변환
- `External Interfaces (DB, API 등 외부 시스템)` → 애플리케이션 외부의 요소

**특징:**  
✅ 핵심 비즈니스 로직이 프레임워크, 데이터베이스 등의 외부 요소에 의존하지 않음  
✅ 테스트가 용이하고, 유지보수성이 뛰어남  
⚠️ 초기에 설계 비용이 증가할 수 있음

**적용 사례:**
- 모바일 및 웹 애플리케이션 (Android, iOS, Spring Boot)

## 3-3. 시스템 아키텍처 패턴

### **1) 모놀리식 아키텍처 (Monolithic Architecture)**

애플리케이션의 모든 기능이 하나의 코드베이스와 실행 환경에서 운영되는 구조를 의미합니다.
UI, 비즈니스 로직, 데이터 액세스 로직이 단일 애플리케이션으로 묶여 배포됩니다.

**특징:**  
✅ 단순한 배포 구조로, 초기 개발 속도가 빠름  
✅ 내부 호출이 빠르기 때문에 성능이 좋을 수 있음  
⚠️ 애플리케이션이 커질수록 유지보수가 어려워지고 배포가 번거로워짐

**적용 사례:**
- 소규모 스타트업 서비스, 초기 단계의 애플리케이션 
- 대형 기업들도 초기에는 모놀리식으로 시작하고, 필요에 따라 마이크로서비스로 전환하는 방식을 많이 활용

### **2) 마이크로서비스 아키텍처 (Microservices Architecture, MSA)**
 
애플리케이션을 여러 개의 독립적인 서비스로 나누어 운영하는 방식입니다.
각 서비스는 독립적인 실행 환경을 가지며, API 또는 메시지 브로커를 통해 서로 통신합니다.

**특징:**  
✅ 서비스 간 독립적 배포 및 확장 가능  
✅ 특정 서비스의 장애가 전체 시스템에 영향을 주지 않음  
⚠️ 서비스 간 통신 비용과 운영 복잡성이 증가할 수 있음

**적용 사례:**
- Netflix, Amazon, 배달의민족 등 서비스 단위로 배포, 확장, 유지보수가 필요한 대규모 시스템.

### **3) 서비스 지향 아키텍처 (Service-Oriented Architecture, SOA)**

**설명:**  
모놀리식과 마이크로서비스의 중간 형태로, 서비스들이 엔터프라이즈 서비스 버스(ESB)를 통해 통신하는 방식입니다.
SOA는 개별적으로 개발된 서비스들이 ESB를 통해 표준화된 방식으로 통합되는 것이 핵심입니다.

>📌 ESB(Enterprise Service Bus)란?  
> ESB는 다양한 애플리케이션과 시스템 간의 데이터를 중앙에서 관리하고 연결하는 통합 플랫폼입니다.  
> 쉽게 말해, 서비스 간의 메시지를 주고받을 수 있는 "중앙 허브" 역할을 합니다.

**특징:**  
✅ 비즈니스 프로세스를 기반으로 서비스가 구성됨  
✅ 기존 시스템과의 통합이 용이  
⚠️ ESB가 병목이 될 가능성이 있으며, 운영이 복잡할 수 있음

**적용 사례:**
- 하나의 고객 정보가 여러 서비스에서 공유되는, SOA 기반의 중앙 통합 시스템이 필요한 경우 (은행, 보험, 공공기관 등)

## 3-4. 아키텍처 간의 관계와 발전 과정

- **레이어드 아키텍처 → 헥사고날/클린 아키텍처로 발전**
  - 기존의 계층적 아키텍처는 유지보수가 어렵고 결합도가 높은 단점이 있었음
  - 이를 해결하기 위해 도메인 로직을 중심으로 한 아키텍처(헥사고날, 클린)가 등장

- **모놀리식 아키텍처 → MSA로 발전**
  - 초기에는 모든 기능을 하나로 합친 모놀리식 구조가 일반적이었음
  - 유지보수와 확장성을 개선하기 위해 독립적인 서비스 단위로 나눈 MSA가 등장

---

# 4. 마무리 - 조영호님의 강의를 듣기 전에

조영호 님은 객체지향 설계와 애플리케이션 아키텍처를 깊이 있게 다루는 전문가입니다.  
강의를 듣기 전에 다음을 고민해보면 어떨까요?

- 객체지향 설계와 아키텍처의 차이를 정확히 이해했는가?
- SOLID 원칙이 실무에서 어떻게 적용되는지 고민해봤는가?
- 현재 내가 작업하는 애플리케이션의 아키텍처는 어떤 방식으로 설계되어 있는가?

이 글을 통해 기본 개념을 익히셨다면, 이제 강의를 들으며 더 깊이 있는 내용을 배워보시죠! 🚀

---

<div>

|Profile| Link                                                                                        | Bio                       |
|--|---------------------------------------------------------------------------------------------|---------------------------|
|<img src="https://avatars.githubusercontent.com/u/97321415?s=96&v=4" width="100" height="100"/> | [github](https://github.com/bk100km) <br/> [LinkedIn](https://www.linkedin.com/in/bk100km/) | **"모든 것은 변한다. 그러니 우리는"** |

</div>
