# SQL이 실행되는 순간, 어떤 일이 벌어질까?
> SQL은 데이터를 다루는 가장 기본적인 도구에요.  
> 하지만 `SELECT`, `INSERT` 같은 SQL이 **DB 내부에서 어떻게 실행되는지**에 대해 생각해볼 기회는 많지 않습니다.  
> SQL 처리의 흐름과 원리를 알아볼까요?

---

### 대상 독자
- SQL이 어떤 과정을 거쳐 실행되는지 알고 싶은 주니어 개발자, 기획자, 데이터 분석가
- 인덱스, 실행계획, 메모리 구조 등을 실무 관점에서 처음 접하는 분

### 읽는 데 걸리는 시간
- 약 7분

---

## 목차

- [Intro](#intro)
  - [SELECT를 쓰면 무슨 일이 벌어질까?](#select를-쓰면-무슨-일이-벌어질까)

- [Body](#Body)
  - [1. SQL은 '질문'이고, DB는 '답'을 찾아준다](#1-sql은-질문이고-db는-답을-찾아준다)
    - [SQL은 선언적 언어다](#sql은-선언적-언어다)
    - [DB는 어떻게 응답할까](#db는-어떻게-응답할까)
    - [옵티마이저란?](#옵티마이저란)
    - [실행 계획이 중요한 이유](#실행-계획이-중요한-이유)

  - [2. 데이터를 더 빠르게 찾기 위한 구조들](#2-데이터를-더-빠르게-찾기-위한-구조들)
    - [인덱스는 왜 필요한가?](#인덱스는-왜-필요한가)
    - [인덱스는 어떻게 동작할까?](#인덱스는-어떻게-동작할까)
    - [풀스캔은 언제 발생할까?](#풀스캔은-언제-발생할까)
    - [인덱스 vs 풀스캔의 기준](#인덱스-vs-풀스캔의-기준)

  - [3. SQL이 효율적으로 실행되기 위한 조건들](#3-sql이-효율적으로-실행되기-위한-조건들)
    - [DB는 왜 메모리를 사용할까?](#db는-왜-메모리를-사용할까)
    - [SGA와 PGA란 무엇인가?](#sga와-pga란-무엇인가)
    - [커서란 무엇인가?](#커서란-무엇인가)
    - [하드 파싱과 소프트 파싱](#하드-파싱과-소프트-파싱)

  - [4. 데이터베이스는 시스템마다 어떻게 다를까?](#4-데이터베이스는-시스템마다-어떻게-다를까)
    - [DBMS는 왜 다를까?](#dbms는-왜-다를까)
    - [어떤 상황에 어떤 DB가 적합할까?](#어떤-상황에-어떤-db가-적합할까)

- [Outro](#outro)
  - [SQL을 이해하는 순간, 더 나은 질문을 할 수 있다](#sql을-이해하는-순간-더-나은-질문을-할-수-있다)

---

## Intro

### SELECT를 쓰면 무슨 일이 벌어질까?

우리는 평소에 너무나도 자연스럽게 `SELECT * FROM 테이블명` 같은 SQL 문장을 작성합니다.  
이렇게 한 줄만 입력하면 DB에서 원하는 데이터를 척척 보여주니까요.  
하지만 이 SQL 문장이 실제로 어떻게 동작하는지, DB 내부에서는 어떤 과정이 일어나는지는 잘 알려지지 않았습니다.

예를 들어, 이런 질문들은 평소에 쉽게 떠오르지 않습니다.

- SQL을 실행하면 실제로 DB는 어떤 일을 하나요?
- DB는 데이터를 어떤 순서로, 어떤 기준으로 찾아내나요?
- 쿼리를 빠르게 하려면 단순히 인덱스만 걸면 되는 걸까요?
- 왜 때로는 동일한 쿼리인데 성능이 달라질까요?

이 글은 그런 질문들에 답하기 위한 여정입니다.  
실제로 DB가 SQL을 해석하고 실행 계획을 수립하고, 메모리 구조를 통해 결과를 응답하기까지의 전 과정을 쉽고 명확하게 설명해보려 합니다.

SQL을 '외워서 쓰는 것'이 아닌 '이해하고 설계하는 도구'로 사용할 수 있도록, 그 첫 걸음을 함께 시작해보시죠.

---

## Body

### 1. SQL은 '질문'이고, DB는 '답'을 찾아준다

#### SQL은 선언적 언어다

SQL은 절차형 언어가 아닙니다.  
예를 들어 "이 테이블을 순회하면서 이 조건에 맞는 값을 찾고, 정렬하고, 출력해"라고 명령하는 것이 아니라,  
"이 조건을 만족하는 데이터를 주세요"라고 **요구**하는 언어입니다.

즉, SQL은 **무엇(What)을 원하는지**만 말하고, **어떻게(How) 처리할지는 DB에게 맡기는 방식**이죠.

#### DB는 어떻게 응답할까?

DB는 우리가 작성한 SQL을 그대로 실행하지 않습니다.  
내부적으로 다음과 같은 순서로 동작합니다.

1. **SQL 파싱**: 작성된 SQL이 문법상 맞는지 확인합니다.
2. **옵티마이저 판단**: 어떤 인덱스를 쓸지, 어떤 테이블을 먼저 조회할지 등을 결정합니다.
3. **실행 계획 수립**: 위 판단을 바탕으로 최적의 실행 절차를 정리합니다.
4. **실행 및 결과 반환**: 정해진 절차에 따라 데이터를 가져와 결과를 돌려줍니다.

#### 옵티마이저란?

옵티마이저(Optimizer)는 DB 안의 '판단 엔진'이라고 볼 수 있습니다.
어떤 인덱스를 사용할지, 어떤 테이블을 먼저 읽을지 등을 **통계 정보와 규칙에 따라** 결정합니다. 예를 들어:

- 테이블 크기나 행 수
- 조건절의 분포도 (예: 특정 값이 전체의 몇 %를 차지하는지)
- 인덱스 유무나 사용 가능성

이런 정보들을 종합해서 옵티마이저는 가장 효율적인 실행 방법을 선택해 실행 계획에 반영합니다.

#### 실행 계획이 중요한 이유

실행 계획(Execution Plan)은 DB가 SQL을 **어떻게 처리할지에 대한 상세 설명서**입니다.

예를 들어, `SELECT * FROM users WHERE age = 30`이라는 SQL을 실행할 때 DB는 다음과 같은 결정을 합니다.

- `users` 테이블을 먼저 읽을지, 조인 대상이 있다면 어떤 순서로 읽을지
- `age` 컬럼의 인덱스를 사용할지
- 정렬은 언제 할지

동일한 SQL 문장이라도 실행 계획이 다르면 **성능은 크게 달라질 수 있습니다**.  
실행 계획을 이해하는 것은 SQL을 잘 쓰는 것 못지않게 중요합니다.

> 꼭 기억하세요.  
> 우리가 SQL을 입력하고 결과를 받는 그 짧은 순간에도,  
> DB는 내부에서 수많은 계산과 판단을 하고 있다는 것을요.

---

### 2. 데이터를 더 빠르게 찾기 위한 구조들

#### 인덱스는 왜 필요한가?

SQL 성능에서 가장 중요한 질문 중 하나는 "**어떻게 데이터를 더 빨리 찾을 수 있을까?**"입니다.

작은 데이터셋이라면 모든 데이터를 하나하나 확인해도 큰 부담이 없지만,  
수십만 건, 수백만 건의 데이터가 있는 테이블에서는 이야기가 달라집니다.

이럴 때 사용하는 것이 **인덱스(Index)**입니다.  
인덱스는 책의 목차처럼 동작합니다.  
책에서 원하는 내용을 찾을 때 처음부터 한 장씩 넘기는 대신,  
목차를 보고 해당 페이지로 바로 이동하듯,
DB도 인덱스를 통해 **필요한 데이터의 위치를 미리 알고 빠르게 접근**할 수 있습니다.

#### 인덱스는 어떻게 동작할까?

대부분의 데이터베이스는 인덱스를 만들 때 **B-Tree(균형 이진 트리)**라는 구조를 사용합니다.  
이 구조는 마치 커다란 나무처럼 생겼습니다.

- 뿌리(Root)에서 시작해 데이터를 분류한 가지(Branch)를 따라 내려가고
- 마지막 잎(Leaf)에서 우리가 찾는 데이터의 주소를 발견합니다

이 과정을 통해 DB는 원하는 데이터를 찾을 때 **한 단계씩 좁혀가며** 탐색할 수 있습니다.

예를 들어, `age` 컬럼에 인덱스가 있고 다음과 같은 쿼리를 실행한다고 가정해 보겠습니다.

```sql
SELECT * FROM users WHERE age = 32
```

이때 DB는 age 인덱스를 따라 B-Tree 구조를 타고 내려가면서 나이 32에 해당하는 데이터 위치를 빠르게 찾아냅니다.  
전체 데이터를 일일이 확인하는 것보다 훨씬 빠르겠죠.

> 인덱스는 빠르게 "찾아가는 길"을 만드는 기술입니다.  
> 단, 이 길이 너무 많아지면 오히려 관리 비용이 증가할 수도 있습니다.

#### 풀스캔은 언제 발생할까?

많은 분들이 “인덱스가 있으면 무조건 빠르다”고 생각하지만,  
**DB는 상황에 따라 오히려 인덱스를 사용하지 않는 편이 더 빠르다고 판단하기도 합니다.**

그 이유는 간단합니다.  
**인덱스를 타고 간 뒤에도 결국 ‘본문’을 읽는 작업이 따로 필요**하기 때문입니다.

책을 읽는다고 생각해봅시다.  
우리는 보통 원하는 내용을 찾기 위해 **목차를 먼저 보고**,  
해당 페이지로 이동해 내용을 읽습니다. 이게 바로 인덱스의 개념입니다.

하지만 만약 그 책의 95%가 우리가 원하는 내용이라면 어떨까요?

- 굳이 목차를 보고 일일이 페이지를 찾아가기보다는
- **처음부터 그냥 순서대로 읽는 게 더 빠르지 않을까요?**

데이터베이스도 마찬가지입니다.  
조건에 맞는 데이터가 **테이블의 대부분일 경우**,  
인덱스를 타고 이동하는 것보다 **처음부터 끝까지 한 번에 읽는 것이 더 효율적**일 수 있습니다.  
이럴 때 풀스캔이 발생하는 거죠.

---

### 3. SQL이 효율적으로 실행되기 위한 조건들

#### DB는 왜 메모리를 사용할까?

DB는 단순하게 디스크에서 데이터를 읽고 쓰는 것에 그치지 않습니다.  
실제로는 **메모리 영역을 적극적으로 활용**합니다. 왜일까요?

디스크는 느리고, CPU는 빠르기 때문입니다.  
디스크에서 데이터를 매번 읽으면 너무 많은 시간이 소요되고,
그 사이 CPU는 할 일이 없어 놀게 됩니다.  
그래서 중간에 빠른 속도의 메모리를 활용해 **속도와 자원의 균형**을 맞추는 것이죠.

#### SGA와 PGA란 무엇인가?

DBMS는 메모리를 크게 두 가지로 나눠 사용합니다.

- **SGA (System Global Area)**: 여러 사용자가 **함께 공유하는 메모리 공간**입니다.
  - 예를 들어, 자주 사용하는 SQL의 실행 계획이나 조회된 데이터를 저장해 두고 재사용합니다.

- **PGA (Program Global Area)**: 각 사용자 세션이 **개인적으로 사용하는 메모리 공간**입니다.
  - 예를 들어, 정렬 중간 결과나 변수 값을 임시로 저장할 때 사용됩니다.

이 구조 덕분에, **동일한 SQL을 여러 번 실행하더라도 불필요한 계산을 줄이고** 더 빠르게 응답할 수 있습니다.

#### 커서란 무엇인가?

SQL이 실행되면, DBMS는 내부적으로 해당 SQL을 위한 **커서(Cursor)**를 생성합니다.

커서는 다음과 같은 중요한 정보를 포함합니다.

- SQL 문장 자체
- 바인드 변수 값
- 실행 계획
- 결과를 처리하기 위한 메모리 정보

즉, 커서는 SQL 실행에 필요한 모든 정보가 담긴 **작은 실행 단위**라고 할 수 있습니다.

> 커서를 잘 관리하면, 같은 SQL을 다시 실행할 때 **처음부터 분석할 필요 없이 재사용**할 수 있어 효율적입니다.

#### 하드 파싱과 소프트 파싱

SQL이 처음 실행될 때는 다음 과정을 거칩니다:

- **하드 파싱 (Hard Parsing)**: SQL을 완전히 새로 분석하고 실행 계획을 수립하는 과정
- **소프트 파싱 (Soft Parsing)**: 이미 분석된 커서를 재활용하는 과정

하드 파싱은 시간이 오래 걸리며, 많은 자원을 소모합니다.  
반면, 소프트 파싱은 이미 만들어진 실행 계획을 재사용하기 때문에 훨씬 빠릅니다.

SQL 튜닝에서는 가능한 한 **소프트 파싱 비율을 높이는 것**이 핵심 전략 중 하나입니다.

SQL 성능을 높이기 위해서는,  
**DB 내부 구조와 동작 원리(SGA, PGA, 커서, 파싱 전략 등)**를 이해하고 활용하는 것이 핵심입니다.

SQL을 빠르게 실행하는 비결은, '얼마나 적게 반복하느냐'입니다.  
메모리 재사용과 커서 전략은 그 반복을 줄이는 가장 강력한 방법입니다

---

### 4. 데이터베이스는 시스템마다 어떻게 다를까?

#### DBMS는 왜 다를까?

모든 데이터베이스는 SQL을 받아서 데이터를 저장하고 꺼내주는 일을 합니다.  
하지만 그 **방식은 시스템마다 다릅니다**.  
사용하는 메모리 구조, 데이터를 저장하는 방식, 실행 계획을 캐싱하는 방식 등에서 차이가 나기 때문에,  
**같은 SQL이라도 DBMS에 따라 성능과 처리 방식이 달라질 수 있습니다.**

아래는 주요 DBMS들의 특징을 비교한 표입니다.

| 항목 | Oracle | PostgreSQL | MySQL | MSSQL |
|------|--------|------------|-------|--------|
| **용도** | 대기업·금융 | 공공·기술 중심 | 웹 서비스 | 윈도우 기업용 |
| **라이선스** | 유료 | 무료 | 무료 + 유료 옵션 | 유료 |
| **인덱스** | 다양 (B-Tree, Bitmap 등) | 확장 가능 (B-Tree, GiST 등) | 단순 (B-Tree 위주) | B-Tree 최적화 |
| **메모리 구조** (SGA/PGA) | 명확히 분리 → 고성능 처리 | 단순, 자동 관리 | 단순 | 명확히 분리 → 고성능 처리 |
| **커서 재사용** | 높음 (공유 커서) | 있음 (자동 처리) | 거의 없음 | 높음 (계획 캐시) |
| **실행 계획 선택** | 통계 기반, 매우 정교함 | 통계 기반, 유연함 | 단순한 최적화 | 통계 기반, 튜닝 쉬움 |

---

#### 어떤 상황에 어떤 DB가 적합할까?

DBMS 선택에 정답은 없습니다.  
중요한 건 **현재 환경과 목적에 맞는 시스템을 고르는 것**입니다.

- **Oracle/MSSQL**: 복잡하지만 정교하고 빠름 → **대형 시스템에 적합**
- **PostgreSQL**: 기능 풍부하고 확장성 좋음 → **기술 유연한 프로젝트**
- **MySQL**: 단순하고 가볍다 → **빠른 개발, 스타트업에 적합**

> DB를 선택하는 기준은 '어떤 문제를 풀고 싶은가'에 달려 있습니다.
> 어떤 DB를 선택하든, 그 시스템의 **내부 구조와 특성을 이해하고 있어야** 성능을 최대한 끌어낼 수 있습니다.

---

### Outro

#### SQL을 이해하는 순간, 더 나은 질문을 할 수 있다

SQL은 단순히 데이터를 조회하거나 수정하는 도구가 아닙니다.  
그 내부에는 파싱, 최적화, 실행, 캐싱, 커서 전략, 메모리 구조 등 여러 시스템 레벨의 동작이 얽혀 있습니다.  
이러한 흐름을, **왜 그 쿼리가 빠른지, 왜 느려지는지**를 알 수 있게 됩니다.

많은 초보자들이 `SELECT * FROM table`을 입력하면  
그냥 데이터가 “나온다”고만 생각합니다.  
하지만 실제로는 DB 내부에서 수많은 판단과 작업이 이뤄지고 있습니다.

- 옵티마이저는 실행 계획을 세우고,
- 인덱스는 효율적인 탐색을 돕고,
- 커서와 메모리는 실행 효율성을 결정하며,
- 각 DBMS는 저마다 최적의 방식으로 질문에 답을 줍니다.

이 글에서 다룬 내용들은 그런 **보이지 않는 흐름의 기초적인 이해**를 위한 출발점입니다.  
여기서 얻은 감각은 이후 쿼리 튜닝, 설계, 시스템 이해로까지 확장될 수 있습니다.

> 결국 중요한 건,  
> 질문을 잘 하려면, 그 질문이 어떻게 처리되는지를 이해해야 한다는 것입니다.

SQL을 쓸 줄 아는 사람은 많습니다.  
하지만 SQL을 **이해하고** 쓰는 사람은, 더 나은 질문을 던지고 더 빠르게 문제를 해결합니다.

