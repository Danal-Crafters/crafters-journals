# Object-Oriented AI
![img.png](img.png)
# 들어가며
요즘 ChatGPT 참 많이들 쓴다.

누군가는 AI와 대화하며 영어를 학습하고

누군가는 본인이 모르는 분야에 접근하기 위해 학습하고

누군가는 본인이 하기 싫어하는 일을 대신 맡긴다.

이는 개발자에게 조금 더 크게 다가오는 것 같다.

바이브 코딩을 해봤거나, AI를 꽤 열심히 써본 사람도 이제 꽤나 흔하게 보이고

AI를 이용한 개발 방법론들도 나오기 시작했다.

백엔드 개발자로 일하면서 ChatGPT와 계속 데이트하다 보니

최근 읽은 조영호님의 '오브젝트', '객체지향의 사실과 오해'의 이론이 자꾸만 생각이 난다.

또한, 최근 회자되고 있는 Argument-Driven Development을 보며 느낀 나의 생각에 대한 글이다.

> 내가 생각하고 있다면 다른 개발자들도 비슷한 생각이지 않을까?
> 
> 이 글로 하여금 그런 분들에게 조금의 이정표가 되길 기도하는 중🙏

## 사전지식: GRASP(General Responsibility Assignment Software Patterns)
GRASP는 Craig Larman이 [Applying UML And Patterns](https://product.kyobobook.co.kr/detail/S000006124796)
에서 소개한 객체지향 설계의 책임 할당 원칙 모음이다.
> "누가 어떤 책임(responsibility)을 가져야 하는가?"
> 
> "어떤 객체가 어떤 역할을 수행해야 하는가?"

를 명확히 하여 객체지향 시스템을 응집도 높고 결합도 낮게 만드는데 목적이 있다.

![img_1.png](img_1.png)

GRASP 에는 총 9가지의 원칙이 있는데, 정리하자면 이렇다.

| No | 패턴 이름                    | 설명                              | 핵심 키워드       |
| -- | ------------------------ | ------------------------------- | ------------ |
| 1  | **Information Expert**   | 가장 많은 정보(데이터)를 가진 객체에게 책임 부여    | 데이터 소유, 응집도  |
| 2  | **Creator**              | 어떤 객체가 다른 객체를 생성할 책임을 가져야 하는가   | 포함, 집합, 초기화  |
| 3  | **Controller**           | 시스템 외부의 입력을 받아 처리할 객체           | 유스케이스, 경계 객체 |
| 4  | **Low Coupling**         | 클래스 간 의존성을 낮춰 변경에 강하게 설계        | 느슨한 연결       |
| 5  | **High Cohesion**        | 클래스가 하나의 목적에 집중하고 명확한 역할을 갖게 설계 | 응집도          |
| 6  | **Polymorphism**         | 동일한 메시지에 다양한 방식으로 반응            | 인터페이스, 추상화   |
| 7  | **Pure Fabrication**     | 응집도나 결합도를 위해 도메인과 무관한 클래스를 만들어냄 | 유틸성 클래스      |
| 8  | **Indirection**          | 두 객체의 직접 연결을 피하고 중간 매개를 둠       | 중개자, 어댑터     |
| 9  | **Protected Variations** | 변할 수 있는 요소로부터 변하지 않는 요소를 보호     | 인터페이스 캡슐화    |
아래의 글에서 사용할 예제로, 가볍게 읽고 넘어가도록 하자.

## Prompt Engineering
처음엔 그저 질문 하나 잘 던지면 되는 줄 알았다.

하지만 인공지능 모델, 특히 요즘 유행하는 LLM(Large Language Model)이라는 녀석은

단순한 질문 하나에도 성격이 휘청이고, 표현 하나에 따라 대답의 깊이가 달라진다.

이런 갈대같은 친구들에게 어떻게 질문할지 공략법? 같은게 생기게 되는데

그게 바로 프롬프트 엔지니어링이다.

![img_2.png](img_2.png)

GRASP 패턴처럼, 프롬프트 엔지니어링에도 여러 종류가 있는데

- Zero-shot: 예시 없이 바로 질문하기 
- Few-shot: 예시 몇 개 주고 유도하기 
- Chain-of-Thought: 사고 흐름을 유도하기 
- Role-based: 역할을 설정해서 질문하기 
- Instruction-based: 구체적인 명령 내리기 
- Reflexion: 대답한 내용을 스스로 평가하게 하기 
- Multi-turn: 대화를 축적하며 이어가기 
- Chaining: 질문 → 대답 → 가공 → 다음 질문 식으로 묶기 
- System Prompt: 아예 인격이나 세계관을 설정하기
- Contextual Prompting: 문맥 전체를 주고 정확도 높이기

이 기법들은 단순히 질문을 "잘" 하는 게 아니라, 

AI에게 책임을 나누고 역할을 부여하고, 응집도와 결합도를 고민하는 작업이다. 

어라, 이거 어디서 본 구조 아닌가?

# GRASP vs Prompt Engineering
객체지향의 설계 원칙인 GRASP와 프롬프트 엔지니어링은 본질적으로 유사한 철학을 공유하는 것 같다.

| GRASP 패턴                 | 대응되는 프롬프트 전략                             | 공통 철학                      |
| ------------------------ |------------------------------------------| -------------------------- |
| **Information Expert**   | Contextual Prompting / Role-based Prompt | 데이터를 가장 많이 가진 곳이 책임을 져야 한다 |
| **Creator**              | Prompt Chaining <br>+ Function Agent     | 결과를 만드는 책임은 구성 요소가 가진다     |
| **Controller**           | Instruction-based Prompt                 | 외부 입력을 받아 처리할 중개자 설정       |
| **Low Coupling**         | System Prompting / Prompt Chaining       | 프롬프트 간의 독립성과 재사용성 확보       |
| **High Cohesion**        | Role-based + CoT Prompt                  | 하나의 역할에 집중된 요청 설계          |
| **Polymorphism**         | Few-shot Prompting                       | 다양한 예시와 상황에 맞춰 유연하게 대응     |
| **Pure Fabrication**     | System Role Prompt                       | 실제 도메인엔 없지만 작업에 필요한 인격 부여  |
| **Indirection**          | Prompt Chaining + Function Agent         | 복잡한 요청을 분리하고 연결함           |
| **Protected Variations** | Instruction Prompt + Constraint Prompt   | 변동성을 줄이기 위한 명세화와 조건 부여     |

이렇게 보면, 프롬프트 엔지니어링은 단순한 트릭이 아니라 **AI라는 객체를 다루는 새로운 방식의 객체지향 설계**라고도 볼 수 있을 것 같다.

LLM 하나를 하나의 객체로 보고, 그 객체에게 적절한 책임과 역할을 부여하는 작업.

이중 몇 가지는 조금 더 자세히 봐야할 것 같다.

## 정보 전문가 패턴

![img_3.png](img_3.png)

흔히들 GPT에게
> 당신은 제게 돈을 벌어줄 세계 최고의 "펀드 매니저" 입니다.

와 같이, AI에게 역할을 부여한 후 그 역할에 맞는 질의를 많이들 한다. 

이게 단순히 말투를 바꾸는 장치처럼 보일 수도 있지만, 사실은 매우 전략적인 접근이다. 

이 프롬프트 하나가 모델에게 암묵적으로 수많은 정보와 태도를 주입한다. 

AI는 자신이 ‘펀드 매니저’로 설정되었을 때, 그에 맞는 어휘와 태도, 판단 논리를 가져오게 된다.

이 역할 부여는 단순한 문장이 아니라 정보 맥락을 전달하는 프레임이 된다.

이런 점에서 Information Expert와 매우 닮아 있다.

객체지향 설계에서는 "데이터를 가장 잘 아는 객체에게 책임을 부여하라"고 말한다. 

프롬프트 엔지니어링에서도 마찬가지다. 특정 작업에 대해 가장 적절한 정보(또는 역할)를 가진 캐릭터를 설정하고, 질문의 맥락을 몰아주어야 한다.

예를 들어, 수학 문제를 잘 풀고 싶다면 이렇게 말할 수 있다:

> 당신은 대한민국 수학 경시대회 금상 수상자입니다. 아래 문제를 차근차근 사고의 흐름을 따라 풀어주세요.

또는 역사적 사실을 알고 싶다면?

> 당신은 역사학 석사 출신이며, 한국사 관련 팟캐스트를 운영하는 유튜버입니다.

이런 문장은 단순히 캐릭터만 부여하는 게 아니다. 

그 캐릭터가 ‘가지고 있어야 할 정보’까지 함께 암시한다.

따라서 정보 전문가 패턴은 프롬프트를 설계할 때 가장 먼저 고려해야 할 기초적인 전략 중 하나다.

위에서 봤던 것 처럼, 실제로도 이 패턴은 다양한 프롬프트 전략의 기반이 된다. 

Role-based Prompt, Contextual Prompting 등은 모두 Information Expert의 철학에서 출발한다. 

GPT나 Claude 같은 LLM이 ‘모든 것을 아는 듯한 존재’라고 생각하기 쉽지만, 사실상 어떤 맥락을 얼마나 똑똑하게 줬느냐에 따라 결과가 갈린다.

정보 전문가 패턴을 기반으로 하면, 다음과 같은 흐름이 가능하다.
```
문제의 주제를 명확히 파악하고
그 주제를 가장 잘 설명할 수 있는 역할을 부여하고
그 역할에 맞게 설명 방식을 조율하고
결과를 평가하고 수정하는 흐름까지 연결하는 것
```
이 방식은 단순히 한 줄 프롬프트를 던지는 게 아니라, ‘정보 책임’을 부여하는 설계이다.

객체지향의 정보 전문가 패턴처럼, AI에게도 책임을 줄 때는 해당 정보를 가장 잘 다룰 수 있는 맥락을 부여해야 한다.

프롬프트 엔지니어링을 잘하는 사람은 결국 정보를 어디에, 어떻게 맡길지를 아는 사람이다.

그리고 그 시작은 바로 Information Expert 패턴을 이해하고 적용하는 데서 출발한다.

![img_4.png](img_4.png)

## 낮은 결합도 패턴 (Low Coupling)
복잡한 작업을 프롬프트 하나에 모두 담으려는 시도는 흔하지만, 

이는 자주 실패로 이어진다.

질문은 길어지고, AI는 어느 부분에 집중해야 할지 모른 채 

불안정한 응답을 내놓는다.

이럴 때 우리가 떠올려야 할 객체지향 설계 원칙이 바로 **낮은 결합도(Low Coupling)** 다.  

GRASP에서 말하는 Low Coupling은 "객체들이 서로 너무 얽히지 않도록 하라"는 원칙이다.  

즉, 하나의 변경이 다른 객체에 파급되지 않도록 만들라는 말이다.

이 철학은 프롬프트 설계에도 똑같이 적용된다.

### 역할은 분리하고, 프롬프트는 가볍게

프롬프트 하나가 너무 많은 책임을 질 때, 그 프롬프트는 쉽게 무너지게 된다.  

따라서 각 기능을 분리하고, 서로 독립적인 단위로 구성해야 한다.

예를 들어 시스템 프롬프트를 사용하면, 역할이나 톤은 전체 맥락에서 고정할 수 있다.

> System: 당신은 정중하고 꼼꼼한 논문 편집자입니다.

이 설정 하나만으로, 이후 모든 프롬프트는 문체나 어조를 설명할 필요가 없어진다.

덕분에 각 프롬프트는 오직 자신이 수행할 기능에만 집중할 수 있다.  

역할이 외부에서 주어지므로, 프롬프트 간 의존성은 줄어든다.

### 체이닝 구조에서도 결합도를 낮춰라

Prompt Chaining에서도 결합도를 낮추는 건 중요하다.  

예를 들어 아래와 같은 구조를 생각해보자

1. Summary Prompt → 요약
2. Translation Prompt → 영어 번역
3. Style Prompt → APA 스타일 적용

이때 요약 방식만 바꾸고 싶다면, 1번 프롬프트만 교체하면 된다.

나머지 프롬프트는 영향을 받지 않는다. 

이처럼 각 단계가 독립적일수록 변경이 쉬워지고, 전체 흐름이 안정적이 된다.

### 유지보수성과 협업 효율

결합도가 낮으면, 여러 명이 동시에 작업하기도 쉽다.  

요약 파트를 담당한 사람은 요약만, 스타일 파트를 담당한 사람은 스타일만 보완하면 된다.  

디버깅도 단순해지고, 문제 원인을 빠르게 찾을 수 있다.

낮은 결합도는 결국 프롬프트의 재사용성과 확장성을 높여준다.  

복잡한 프롬프트 구조일수록 이 원칙은 더욱 중요하다.  

결합도가 낮은 설계는 언제나 바꿔쓰기 쉽고, 덜 망가지며, 더 오래 간다.

## 두 개밖에 안 봤는데
벌써 머리아프고 힘들다. GRASP의 내용을 모두 작성하기에는 모두가 이쯤에서 닫을 듯 하니, 간단히 정리해보겠다.

Vibe coding을 하다 보면, 점점 자주 사용하는 기능(ex: 이 JSON을 data class로 변형해줘)을 따로 분리하게 되는 것 같다.

처음부터 앱 만들어달라고 찡찡대지 않고, 우리 개발자들이 자주 하는 것 처럼 프로젝트를 만들고 차근차근 뭔가를 만들어간다.

이는, 대충 던졌을 때 응답이 알차게 나오지 않아 재질의를 반복하며, 사용자들이 체득한 결과이다.

### 나는 어디까지 해 봤냐면
롤 플레잉을 극한까지 해봤다.

![img_5.png](img_5.png)

> 나와 비슷한 연차부터 20년차까지 분야도 다채롭게 설정한 AI들을 데리고 
> 
> 토론을 시켰다.
> 
> 가장 좋은 시스템 아키텍처는 무엇인가?

아쉽게도, 결과는 아직 나오지 않았다.

내가 사용하는 ChatGPT Plus token을 금새 다 쓰더라.

~~그래서 지금 이 글도 ChatGPT의 맛을 하나도 먹이지 못한 생 상민 글이다.~~

월이 지나서 토큰이 살아났다 ^__^

이런 의사결정주체 같은것도 좋지만, 실제 실무에도 적용해보고 싶은 마음이 크다.

### MetaGPT
위의 '실무에도 적용하고픈'의 단락에서

실제로 이런 프로젝트를 하나 발견하게 되었다.

이걸 모두 설명하기엔 한계가 있을테니, 잘 만들어진 게시글로 대체하여 공유한다.

[MetaGPT Framework](https://www.unite.ai/ko/metagpt-complete-guide-to-the-best-ai-agent-available-right-now/)

[mgx.dev](https://mgx.dev/)

# Argument Programming

![img_6.png](img_6.png)

우리의 형님 켄트벡은

24년 말 Argument-Driven Development라는 개념을 제안했고,

최근 들어 크게 회자되기 시작했다.

이는 기존의 
```
TDD(Test-Driven Development)
OOP(Object-Oriented Programming)
FP(Functional Programming)
```
에서 한 발 더 나아가 

프로그래밍의 본질을 '주장(argument)'의 흐름으로 바라보는 철학적 시도라 할 수 있다.

## 왜 'Argument'인가?
켄트 백이 말하는 'Argument'는 단순한 함수의 인자를 뜻하지 않는다. 

여기서 Argument는 논리적 주장, 입장, 해석을 말한다.

그는 프로그래밍이란 결국 

“이 데이터는 이렇게 해석되어야 한다” 혹은 “이 조건에서는 이런 판단을 해야 한다”

와 같은 연속적인 주장과 그에 대한 검증의 흐름이라고 본다. 

따라서 좋은 코드란 단순히 작동하는 코드가 아니라, 

자기 주장을 논리적으로 잘 전달하고, 반론에 강한 코드라고 말한다.

## 개념 요약
Argument-Driven Programming은 다음과 같은 흐름으로 요약된다.
- 개발자는 주장한다 – “이 문제는 이렇게 해결되어야 한다.” 
- 코드는 주장한 내용을 표현한다 – 명확한 변수 이름, 분기, 책임 분리 등을 통해. 
- 테스트는 반론을 제기한다 – 예외 상황, 경계값, 예상치 못한 입력에 대해. 
- 디자인은 논쟁의 장을 만든다 – 여러 개의 모듈/객체가 자신의 주장으로 조율되는 구조

## 객체지향과의 연결
Argument-Driven Programming은 객체지향 설계와 잘 어울린다. 

객체지향의 핵심은 객체에게 책임을 부여하고, 메시지를 주고받게 하는 것이다. 

여기서 각 객체는 **자신만의 관점과 해석(Argument)** 을 가지고 있으며, 

상호작용을 통해 하나의 합의를 이룬다.

예를 들어 결제 시스템을 설계한다고 할 때
- PaymentValidator는 “이 결제는 유효하지 않다”라고 주장할 수도 있다. 
- CouponPolicy는 “이 쿠폰은 여기서 적용되어야 한다”고 말한다. 
- OrderProcessor는 이 주장들을 종합해서 최종 결정을 내린다.

이는 마치 다자 토론처럼

각 객체가 자신의 논리를 주장하고, 협의점을 찾아가는 구조이다. 

Argument-Driven Programming은 이 흐름을 전제로 코드를 설계하라고 제안한다.

## 프롬프트 엔지니어링과의 연결

LLM과의 대화에서도 Argument는 중심 개념이 될 수 있다. 

사용자는 하나의 입장(“이건 요약되어야 해”, “이건 영어로 바뀌어야 해”)을 AI에게 제시한다. 

그리고 프롬프트는 이 주장을 어떻게든 명확하게 설명하려 한다.

이 때 중요한 건 

AI가 그 주장을 ‘잘 이해했는가’가 아니라, 

주장의 배경이 충분히 전달되었는가이다. 

프롬프트가 명확한 역할, 조건, 예시를 포함해야 좋은 응답을 얻을 수 있는 이유도 

바로 여기에 있다. 

애매한 주장에는 애매한 반응이 돌아오고, 날카로운 주장에는 구조화된 대답이 나온다.

Argument-Driven Programming의 관점에서 보면, 

프롬프트는 결국 "AI에게 건네는 주장"이다. 

그리고 AI의 응답은 그 주장에 대한 하나의 반론 또는 공감이다. 

따라서 프롬프트 설계는 

주장에 대한 설득력, 구조화, 반례 대응까지를 고려하는 

논증적 프로세스로 바라볼 수 있다.

Argument-Driven Programming은 말장난처럼 보일 수 있지만, 

실제로는 프로그래밍을 논리, 논증, 책임, 반응의 연속으로 바라보게 하는 

매우 직관적인 틀이다. 

코드 하나, 프롬프트 하나에도 

“이건 왜 이런 구조여야 하는가?”라는 물음을 던지게 만든다.

켄트 백이 주창한 이 개념은, AI 시대의 개발자에게 아주 의미 있는 시사점을 던져준다.

- 코드는 주장이어야 한다. 
- 테스트는 반론이어야 한다. 
- 설계는 논쟁이어야 한다. 
- 그리고 프롬프트는 협상의 언어다.

Argument-Driven Programming은 어쩌면, 

객체지향 이후 우리가 놓쳤던 
**'설명 가능한 코드'** 의 본질을 되찾기 위한 회귀일지도 모른다.

[켄트백 논의 요약](https://joshua-j-morley.medium.com/applying-object-oriented-design-principles-to-ai-agentic-systems-a-novel-approach-0e2cc3db55db)

---

![img_7.png](img_7.png)
## 마무리하며
예전의 프롬프트 엔지니어링은 'AI와 말 잘하는 기술'같은 걸로 끝났던 거 같은데

이젠 프롬프트 엔지니어링을 감싼 무언가가 제안될 시기라고 본다.

개발자로서 AI와 협업하려면, 질문을 넘어 구조를 설계하고, 

흐름을 조율하는 능력 또한 강하게 요구된다.

아키텍처를 그릴 줄 아는 개발자가 짜는 바이브 코드와 그렇지 않은 코드는 크게 다른 퀄리티를 발한다.

객체지향의 시초도 '제대로 되지 않던 협업을 효율적으로 하기 위해' 제안된 패러다임이다.

켄트 벡의 Argument Programming도, MetaGPT Framework도

모두 업무와 책임을 나누어 각 AI가 맡은 롤을 성실하게 수행할 수 있도록 돕는다.

아마 누군가 저명한 사람이 제안할 거 같지만, 객체지향 AI 방법론이라는 것도 나오게 될 것 같다.

난 이미 비슷하게 사용하고 있는 거 같은데, 다른 개발자들도 이미 비슷하게 사용하고 있을 것 같다.

GRASP가 말하는 각 책임의 분리, 응집도, 결합도 같은 개념들은 

LLM과 상호작용할 때에도 동일하게 적용된다. 오히려 더 절실하다. 

LLM은 하나의 거대한 '객체'다. 

우리는 그 객체에게 요청하고, 응답받고, 다시 수정하며 공동 작업을 이어간다. 

그러려면 프롬프트는 잘 설계된 메서드처럼 동작해야 한다.

그리고 이 철학은 단지 ChatGPT 같은 도구에 그치지 않는다. 

이제 다양한 에이전트 프레임워크들이 등장하고 있다. 

MetaGPT, AutoGen, CrewAI, LangGraph 등은 

모두 '에이전트'라는 객체들을 연결하고 조율하는 시스템이다.

프롬프트 엔지니어링이란 결국 객체지향 설계와 비슷한 것 같다. 

단지 언어가 코드에서 자연어로 바뀌었을 뿐이다. 

우리는 이제 자연어로 인터페이스를 설계하고, 의도를 분리하고, 책임을 나누고, 데이터를 주입하고, 응답을 처리하는 시대에 들어설 것 같다.

물론이지만, 베이스를 공부한 사람이어야 AI의 문제점을 발견할 수 있을 터이니

내가 눈으로 볼 수 있는 모든 분야에 대해

공부를 소홀히 하면 안 되겠다.

결국 우리가 하는 일은 같다.
**무언가에게 책임을 나눠주고, 적절한 요청을 던지는 것.**
그게 객체이든, AI이든 말이다.

> ChatGPT는 새로운 객체다. 그리고 우리는, 설계자다.