# Object-Oriented AI
# 들어가며
요즘 ChatGPT 참 많이들 쓴다.

누군가는 AI와 대화하며 영어를 학습하고

누군가는 본인이 모르는 분야에 접근하기 위해 학습하고

누군가는 본인이 하기 싫어하는 일을 대신 맡긴다.

이는 개발자에게 조금 더 크게 다가오는 것 같다.

바이브 코딩을 해봤거나, AI를 꽤 열심히 써본 사람도 이제 꽤나 흔하게 보이고

AI를 이용한 개발 방법론들도 나오기 시작했다.

백엔드 개발자로 일하면서 ChatGPT와 계속 데이트하다 보니

최근 읽은 조영호님의 '오브젝트', '객체지향의 사실과 오해'의 이론이 자꾸만 생각이 난다.

오늘 글은 이와 관련된 글이며, 이러한 개념도 언젠가 저명하신 분이 제안할 것 같아 남긴다.

> 이 글이 성지가 되길 기도하는 중🙏

## 사전지식: GRASP(General Responsibility Assignment Software Patterns)
GRASP는 Craig Larman이 [Applying UML And Patterns](https://product.kyobobook.co.kr/detail/S000006124796)
에서 소개한 객체지향 설계의 책임 할당 원칙 모음이다.
> "누가 어떤 책임(responsibility)을 가져야 하는가?"
> 
> "어떤 객체가 어떤 역할을 수행해야 하는가?"

를 명확히 하여 객체지향 시스템을 응집도 높고 결합도 낮게 만드는데 목적이 있다.

GRASP 에는 총 9가지의 원칙이 있는데, 정리하자면 이렇다.

| No | 패턴 이름                    | 설명                              | 핵심 키워드       |
| -- | ------------------------ | ------------------------------- | ------------ |
| 1  | **Information Expert**   | 가장 많은 정보(데이터)를 가진 객체에게 책임 부여    | 데이터 소유, 응집도  |
| 2  | **Creator**              | 어떤 객체가 다른 객체를 생성할 책임을 가져야 하는가   | 포함, 집합, 초기화  |
| 3  | **Controller**           | 시스템 외부의 입력을 받아 처리할 객체           | 유스케이스, 경계 객체 |
| 4  | **Low Coupling**         | 클래스 간 의존성을 낮춰 변경에 강하게 설계        | 느슨한 연결       |
| 5  | **High Cohesion**        | 클래스가 하나의 목적에 집중하고 명확한 역할을 갖게 설계 | 응집도          |
| 6  | **Polymorphism**         | 동일한 메시지에 다양한 방식으로 반응            | 인터페이스, 추상화   |
| 7  | **Pure Fabrication**     | 응집도나 결합도를 위해 도메인과 무관한 클래스를 만들어냄 | 유틸성 클래스      |
| 8  | **Indirection**          | 두 객체의 직접 연결을 피하고 중간 매개를 둠       | 중개자, 어댑터     |
| 9  | **Protected Variations** | 변할 수 있는 요소로부터 변하지 않는 요소를 보호     | 인터페이스 캡슐화    |

## Prompt Engineering
처음엔 그저 질문 하나 잘 던지면 되는 줄 알았다.

하지만 인공지능 모델, 특히 요즘 유행하는 LLM(Large Language Model)이라는 녀석은

단순한 질문 하나에도 성격이 휘청이고, 표현 하나에 따라 대답의 깊이가 달라진다.

이런 갈대같은 친구들에게 어떻게 질문할지 공략법? 같은게 생기게 되는데

그게 바로 프롬프트 엔지니어링이다.

GRASP 패턴처럼, 프롬프트 엔지니어링에도 여러 종류가 있는데

- Zero-shot: 예시 없이 바로 질문하기 
- Few-shot: 예시 몇 개 주고 유도하기 
- Chain-of-Thought: 사고 흐름을 유도하기 
- Role-based: 역할을 설정해서 질문하기 
- Instruction-based: 구체적인 명령 내리기 
- Reflexion: 대답한 내용을 스스로 평가하게 하기 
- Multi-turn: 대화를 축적하며 이어가기 
- Chaining: 질문 → 대답 → 가공 → 다음 질문 식으로 묶기 
- System Prompt: 아예 인격이나 세계관을 설정하기
- Contextual Prompting: 문맥 전체를 주고 정확도 높이기

이 기법들은 단순히 질문을 "잘" 하는 게 아니라, AI에게 책임을 나누고 역할을 부여하고, 응집도와 결합도를 고민하는 작업이다. 어라, 이거 어디서 본 구조 아닌가?

# GRASP vs Prompt Engineering
객체지향의 설계 원칙인 GRASP와 프롬프트 엔지니어링은 본질적으로 유사한 철학을 공유하는 것 같다.

| GRASP 패턴                 | 대응되는 프롬프트 전략                             | 공통 철학                      |
| ------------------------ |------------------------------------------| -------------------------- |
| **Information Expert**   | Contextual Prompting / Role-based Prompt | 데이터를 가장 많이 가진 곳이 책임을 져야 한다 |
| **Creator**              | Prompt Chaining <br>+ Function Agent     | 결과를 만드는 책임은 구성 요소가 가진다     |
| **Controller**           | Instruction-based Prompt                 | 외부 입력을 받아 처리할 중개자 설정       |
| **Low Coupling**         | System Prompting / Prompt Chaining       | 프롬프트 간의 독립성과 재사용성 확보       |
| **High Cohesion**        | Role-based + CoT Prompt                  | 하나의 역할에 집중된 요청 설계          |
| **Polymorphism**         | Few-shot Prompting                       | 다양한 예시와 상황에 맞춰 유연하게 대응     |
| **Pure Fabrication**     | System Role Prompt                       | 실제 도메인엔 없지만 작업에 필요한 인격 부여  |
| **Indirection**          | Prompt Chaining + Function Agent         | 복잡한 요청을 분리하고 연결함           |
| **Protected Variations** | Instruction Prompt + Constraint Prompt   | 변동성을 줄이기 위한 명세화와 조건 부여     |


이렇게 보면, 프롬프트 엔지니어링은 단순한 트릭이 아니라 **AI라는 객체를 다루는 새로운 방식의 객체지향 설계**라고도 볼 수 있을 것 같다.

LLM 하나를 하나의 객체로 보고, 그 객체에게 적절한 책임과 역할을 부여하는 작업.

이중 몇 가지는 조금 더 자세히 봐야할 것 같다.

## 정보 전문가 패턴
흔히들 GPT에게
> 당신은 제게 돈을 벌어줄 세계 최고의 "펀드 매니저" 입니다.

와 같이, AI에게 역할을 부여한 후 그 역할에 맞는 질의를 많이들 한다. 

이게 단순히 말투를 바꾸는 장치처럼 보일 수도 있지만, 사실은 매우 전략적인 접근이다. 

이 프롬프트 하나가 모델에게 암묵적으로 수많은 정보와 태도를 주입한다. 

AI는 자신이 ‘펀드 매니저’로 설정되었을 때, 그에 맞는 어휘와 태도, 판단 논리를 가져오게 된다.

이 역할 부여는 단순한 문장이 아니라 정보 맥락을 전달하는 프레임이 된다.

이런 점에서 Information Expert와 매우 닮아 있다.

객체지향 설계에서는 "데이터를 가장 잘 아는 객체에게 책임을 부여하라"고 말한다. 

프롬프트 엔지니어링에서도 마찬가지다. 특정 작업에 대해 가장 적절한 정보(또는 역할)를 가진 캐릭터를 설정하고, 질문의 맥락을 몰아주어야 한다.

예를 들어, 수학 문제를 잘 풀고 싶다면 이렇게 말할 수 있다:

> 당신은 대한민국 수학 경시대회 금상 수상자입니다. 아래 문제를 차근차근 사고의 흐름을 따라 풀어주세요.

또는 역사적 사실을 알고 싶다면?

> 당신은 역사학 석사 출신이며, 한국사 관련 팟캐스트를 운영하는 유튜버입니다.

이런 문장은 단순히 캐릭터만 부여하는 게 아니다. 

그 캐릭터가 ‘가지고 있어야 할 정보’까지 함께 암시한다.

따라서 정보 전문가 패턴은 프롬프트를 설계할 때 가장 먼저 고려해야 할 기초적인 전략 중 하나다.

위에서 봤던 것 처럼, 실제로도 이 패턴은 다양한 프롬프트 전략의 기반이 된다. 

Role-based Prompt, Contextual Prompting 등은 모두 Information Expert의 철학에서 출발한다. 

GPT나 Claude 같은 LLM이 ‘모든 것을 아는 듯한 존재’라고 생각하기 쉽지만, 사실상 어떤 맥락을 얼마나 똑똑하게 줬느냐에 따라 결과가 갈린다.

정보 전문가 패턴을 기반으로 하면, 다음과 같은 흐름이 가능하다.
```
문제의 주제를 명확히 파악하고
그 주제를 가장 잘 설명할 수 있는 역할을 부여하고
그 역할에 맞게 설명 방식을 조율하고
결과를 평가하고 수정하는 흐름까지 연결하는 것
```
이 방식은 단순히 한 줄 프롬프트를 던지는 게 아니라, ‘정보 책임’을 부여하는 설계이다.

객체지향의 정보 전문가 패턴처럼, AI에게도 책임을 줄 때는 해당 정보를 가장 잘 다룰 수 있는 맥락을 부여해야 한다.

프롬프트 엔지니어링을 잘하는 사람은 결국 정보를 어디에, 어떻게 맡길지를 아는 사람이다.

그리고 그 시작은 바로 Information Expert 패턴을 이해하고 적용하는 데서 출발한다.

## 컨트롤러 패턴 (Controller)
Controller 패턴은 입력과 요청이 시스템 외부에서 유입될 때, 

이를 내부로 전달하고 적절한 응답 흐름을 조정하는 역할이다. 

쉽게 말해 '사용자의 요구를 받아 적절한 객체에 책임을 위임하는 중간자'라고 할 수 있다. 

객체지향 설계에서 이 패턴은 보통 시스템의 유즈케이스를 처리하는 첫 번째 진입점으로 등장한다.

프롬프트 엔지니어링에서도 Instruction-based Prompt가 바로 이런 컨트롤러 역할을 수행한다. 

사용자는 복잡하고 추상적인 요구를 던진다. 

예를 들어 

“보고서를 요약하고, 중요도를 색상으로 표시해줘” 같은 요청이다. 이걸 AI가 바로 이해하고 처리하기는 어렵다. 

여기서 Instruction Prompt는 사용자의 요구를 세분화하고 구체화해서 AI에게 올바른 작업 순서를 부여하는 매개체가 된다.

예시를 보자
```
“이 긴 보고서 요약 좀 해줘. 핵심은 색으로 구분해서 알려줘.”

이를 Instruction Prompt로 전환하면

“아래 텍스트를 읽고, 핵심 문장을 요약한 뒤, 중요도에 따라 하이라이트 표시를 해주세요. 중요도는 (상, 중, 하)로 나누고 색상은 각각 빨강, 주황, 회색으로 설정하세요.”
```

Instruction-based Prompt는 단순한 요청이 아니라

AI의 작업 단위를 분할하고, 각 단계를 명시적으로 표현한다. 

이건 객체지향의 컨트롤러가 유저의 액션을 받아 도메인 로직에 전달하고, 그 결과를 표현 계층으로 반환하는 구조와 똑같다.

특히 최근의 멀티에이전트 시스템이나 플로우 기반 LLM 구성에서는 이 컨트롤러 역할이 더욱 중요해진다. 

사용자 요청을 어떻게 이해하고, 어떤 에이전트를 호출할 것인지 결정하는 로직은 거의 전적으로 Instruction Layer에 달려 있다. 

마치 Web MVC 패턴에서 Controller가 요청 URL에 따라 내부 로직을 라우팅하듯 말이다.

결론적으로, 프롬프트에서 Controller 패턴은 단지 명령을 전달하는 수준을 넘어선다. 

사용자 요구를 해석하고, 구조화하며, 내부 시스템(AI)에게 명확하게 전달하는 인터페이스이자, 흐름의 시작점이다. 

제대로 된 컨트롤러가 있어야 LLM이라는 거대한 객체가 제대로 동작한다.

프롬프트 설계에서 Instruction은 그만큼 전략적이고, 핵심적인 역할이다.

## 낮은 결합도 패턴 (Low Coupling)

프롬프트 설계에서 종종 실수하는 것이 하나의 질문에 너무 많은 기능을 때려 넣는 것이다. 

사용자 입장에서는 간편하지만, LLM 입장에서는 다양한 요구가 섞인 복잡한 명령은 일관성 없는 결과를 만들게 된다. 

이런 상황에서 중요한 설계 철학이 바로 ‘낮은 결합도’다.

GRASP의 Low Coupling은 객체 간의 의존성을 최소화해서 유지보수성과 확장성을 높이자는 개념이다. 

하나의 변경이 다른 객체에 최소한으로 영향을 주도록 만들라는 것이다. 

이 철학은 프롬프트 설계에도 그대로 적용된다. 즉, 하나의 프롬프트가 다른 프롬프트에 불필요하게 의존하지 않도록, 역할과 책임을 분리하는 것이다.

예를 들어 System Prompt를 활용하면, AI의 역할이나 성격을 일관되게 설정할 수 있다. 

> System: 당신은 정중하고 꼼꼼한 논문 편집자입니다.

이후 사용자는 “이 논문 문장 수정해줘”, “요약해줘”, “APA 스타일로 바꿔줘” 등 다양한 작업을 지시할 수 있다. 

그 어떤 작업이든 프롬프트 자체는 오직 해당 기능에만 집중할 수 있고, 성격이나 역할에 대한 반복적인 설명은 생략해도 된다. 

이로써 각 프롬프트의 책임이 작고 명확해지며, 다른 프롬프트와 느슨하게 연결된다.

또한 Prompt Chaining에서도 

각 단계가 명확히 분리되어 있다면, 한 단계를 수정하더라도 다른 프롬프트에 영향을 주지 않는다. 

예를 들어, 요약하는 방식만 바꾸고 싶다면 Summary Prompt만 교체하면 되고, 그 뒤의 번역이나 스타일링 프롬프트는 그대로 사용할 수 있다. 

이런 구조는 마치 인터페이스나 추상화된 API 모듈처럼 프롬프트 간 관계를 유연하게 만들어준다.

낮은 결합도를 유지하는 프롬프트 설계는 협업에서도 매우 유리하다. 

팀원들이 각각의 역할을 나누어 프롬프트를 관리할 수 있고, 특정 기능에 문제가 발생했을 때 해당 부분만 점검하면 되므로 디버깅이나 개선이 빠르다.

결론적으로

Low Coupling은 프롬프트를 독립적이고 모듈화된 단위로 유지하게 해주며

이는 시스템의 유지보수성과 확장성을 높이는 데 크게 기여한다.

복잡한 프롬프트일수록, 이 철학은 더 중요해진다.

## 두 개밖에 안 봤는데
벌써 머리아프고 힘들다. GRASP의 내용을 모두 작성하기에는 모두가 이쯤에서 닫을 듯 하니, 간단히 정리해보겠다.

Vibe coding을 하다 보면, 점점 자주 사용하는 기능(ex: 이 JSON을 data class로 변형해줘)을 따로 분리하게 되는 것 같다.

처음부터 앱 만들어달라고 찡찡대지 않고, 우리 개발자들이 자주 하는 것 처럼 프로젝트를 만들고 차근차근 뭔가를 만들어간다.

이는, 대충 던졌을 때 응답이 알차게 나오지 않아 재질의를 반복하며, 사용자들이 체득한 결과이다.

### 나는 어디까지 해 봤냐면
롤 플레잉을 극한까지 해봤다.
> 나와 비슷한 연차부터 20년차까지 분야도 다채롭게 설정한 AI들을 데리고 
> 
> 토론을 시켰다.
> 
> 가장 좋은 시스템 아키텍처는 무엇인가?

아쉽게도, 결과는 아직 나오지 않았다.

내가 사용하는 ChatGPT Plus token을 금새 다 쓰더라.

~~그래서 지금 이 글도 ChatGPT의 맛을 하나도 먹이지 못한 생 상민 글이다.~~

월이 지나서 토큰이 살아났다 ^__^

이런 의사결정주체 같은것도 좋지만, 실제 실무에도 적용해보고 싶은 마음이 크다.

### MetaGPT
위의 '실무에도 적용하고픈'의 단락에서

실제로 이런 프로젝트를 하나 발견하게 되었다.

이걸 모두 설명하기엔 한계가 있을테니, 잘 만들어진 게시글로 대체하여 공유한다.

[MetaGPT Framework](https://www.unite.ai/ko/metagpt-complete-guide-to-the-best-ai-agent-available-right-now/)

[mgx.dev](https://mgx.dev/)

# Argument Programming
우리의 형님 켄트벡은

24년 말 Argument-Driven Development라는 개념을 제안했다.

이는 기존의 
```
TDD(Test-Driven Development)
OOP(Object-Oriented Programming)
FP(Functional Programming)
```
에서 한 발 더 나아가 

프로그래밍의 본질을 '주장(argument)'의 흐름으로 바라보는 철학적 시도라 할 수 있다.


## 왜 'Argument'인가?
켄트 백이 말하는 'Argument'는 단순한 함수의 인자를 뜻하지 않는다. 

여기서 Argument는 논리적 주장, 입장, 해석을 말한다.

그는 프로그래밍이란 결국 

“이 데이터는 이렇게 해석되어야 한다” 혹은 “이 조건에서는 이런 판단을 해야 한다”

와 같은 연속적인 주장과 그에 대한 검증의 흐름이라고 본다. 

따라서 좋은 코드란 단순히 작동하는 코드가 아니라, 

자기 주장을 논리적으로 잘 전달하고, 반론에 강한 코드라고 말한다.

## 개념 요약
Argument-Driven Programming은 다음과 같은 흐름으로 요약된다.
- 개발자는 주장한다 – “이 문제는 이렇게 해결되어야 한다.” 
- 코드는 주장한 내용을 표현한다 – 명확한 변수 이름, 분기, 책임 분리 등을 통해. 
- 테스트는 반론을 제기한다 – 예외 상황, 경계값, 예상치 못한 입력에 대해. 
- 디자인은 논쟁의 장을 만든다 – 여러 개의 모듈/객체가 자신의 주장으로 조율되는 구조

## 객체지향과의 연결
Argument-Driven Programming은 객체지향 설계와 잘 어울린다. 객체지향의 핵심은 객체에게 책임을 부여하고, 메시지를 주고받게 하는 것이다. 여기서 각 객체는 **자신만의 관점과 해석(Argument)**을 가지고 있으며, 상호작용을 통해 하나의 합의를 이룬다.

예를 들어 결제 시스템을 설계한다고 할 때
- PaymentValidator는 “이 결제는 유효하지 않다”라고 주장할 수도 있다. 
- CouponPolicy는 “이 쿠폰은 여기서 적용되어야 한다”고 말한다. 
- OrderProcessor는 이 주장들을 종합해서 최종 결정을 내린다.

이는 마치 다자 토론처럼

각 객체가 자신의 논리를 주장하고, 협의점을 찾아가는 구조이다. 

Argument-Driven Programming은 이 흐름을 전제로 코드를 설계하라고 제안한다.

## 프롬프트 엔지니어링과의 연결

LLM과의 대화에서도 Argument는 중심 개념이 될 수 있다. 

사용자는 하나의 입장(“이건 요약되어야 해”, “이건 영어로 바뀌어야 해”)을 AI에게 제시한다. 

그리고 프롬프트는 이 주장을 어떻게든 명확하게 설명하려 한다.

이 때 중요한 건 

AI가 그 주장을 ‘잘 이해했는가’가 아니라, 

주장의 배경이 충분히 전달되었는가이다. 

프롬프트가 명확한 역할, 조건, 예시를 포함해야 좋은 응답을 얻을 수 있는 이유도 

바로 여기에 있다. 

애매한 주장에는 애매한 반응이 돌아오고, 날카로운 주장에는 구조화된 대답이 나온다.

Argument-Driven Programming의 관점에서 보면, 

프롬프트는 결국 "AI에게 건네는 주장"이다. 

그리고 AI의 응답은 그 주장에 대한 하나의 반론 또는 공감이다. 

따라서 프롬프트 설계는 

주장에 대한 설득력, 구조화, 반례 대응까지를 고려하는 

논증적 프로세스로 바라볼 수 있다.

Argument-Driven Programming은 말장난처럼 보일 수 있지만, 

실제로는 프로그래밍을 논리, 논증, 책임, 반응의 연속으로 바라보게 하는 

매우 직관적인 틀이다. 

코드 하나, 프롬프트 하나에도 

“이건 왜 이런 구조여야 하는가?”라는 물음을 던지게 만든다.

켄트 백이 주창한 이 개념은, AI 시대의 개발자에게 아주 의미 있는 시사점을 던져준다.

- 코드는 주장이어야 한다. 
- 테스트는 반론이어야 한다. 
- 설계는 논쟁이어야 한다. 
- 그리고 프롬프트는 협상의 언어다.

Argument-Driven Programming은 어쩌면, 

객체지향 이후 우리가 놓쳤던 
**'설명 가능한 코드'** 의 본질을 되찾기 위한 회귀일지도 모른다.

[켄트백 논의 요약](https://joshua-j-morley.medium.com/applying-object-oriented-design-principles-to-ai-agentic-systems-a-novel-approach-0e2cc3db55db)

---

## 마무리하며
예전의 프롬프트 엔지니어링은 'AI와 말 잘하는 기술'같은 걸로 끝났던 거 같은데

이젠 프롬프트 엔지니어링을 감싼 무언가가 제안될 시기라고 본다.

개발자로서 AI와 협업하려면, 질문을 넘어 구조를 설계하고, 

흐름을 조율하는 능력 또한 강하게 요구된다.

아키텍처를 그릴 줄 아는 개발자가 짜는 바이브 코드와 그렇지 않은 코드는 크게 다른 퀄리티를 발한다.

객체지향의 시초도 '제대로 되지 않던 협업을 효율적으로 하기 위해' 제안된 패러다임이다.

켄트 백의 Argument Programming도, MetaGPT Framework도

모두 업무와 책임을 나누어 각 AI가 맡은 롤을 성실하게 수행할 수 있도록 돕는다.

아마 누군가 저명한 사람이 제안할 거 같지만, 객체지향 AI 방법론이라는 것도 나오게 될 것 같다.

난 이미 비슷하게 사용하고 있는 거 같은데, 다른 개발자들도 이미 비슷하게 사용하고 있을 것 같다.

GRASP가 말하는 각 책임의 분리, 응집도, 결합도 같은 개념들은 

LLM과 상호작용할 때에도 동일하게 적용된다. 오히려 더 절실하다. 

LLM은 하나의 거대한 '객체'다. 

우리는 그 객체에게 요청하고, 응답받고, 다시 수정하며 공동 작업을 이어간다. 

그러려면 프롬프트는 잘 설계된 메서드처럼 동작해야 한다.

그리고 이 철학은 단지 ChatGPT 같은 도구에 그치지 않는다. 

이제 다양한 에이전트 프레임워크들이 등장하고 있다. 

MetaGPT, AutoGen, CrewAI, LangGraph 등은 

모두 '에이전트'라는 객체들을 연결하고 조율하는 시스템이다.

프롬프트 엔지니어링이란 결국 객체지향 설계와 비슷한 것 같다. 

단지 언어가 코드에서 자연어로 바뀌었을 뿐이다. 

우리는 이제 자연어로 인터페이스를 설계하고, 의도를 분리하고, 책임을 나누고, 데이터를 주입하고, 응답을 처리하는 시대에 들어설 것 같다.

물론이지만, 베이스를 공부한 사람이어야 AI의 문제점을 발견할 수 있을 터이니

내가 눈으로 볼 수 있는 모든 분야에 대해

공부를 소홀히 하면 안 되겠다.

결국 우리가 하는 일은 같다.
**무언가에게 책임을 나눠주고, 적절한 요청을 던지는 것.**
그게 객체이든, AI이든 말이다.

> ChatGPT는 새로운 객체다. 그리고 우리는, 설계자다.